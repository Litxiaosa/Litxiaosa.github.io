{"meta":{"title":"潇洒的博客","subtitle":"一个Java码农，喜欢看书，对吉他有点小兴趣。","description":null,"author":"潇洒","url":"http://litxiaosa.me"},"pages":[{"title":"archives","date":"2017-12-01T09:17:17.088Z","updated":"2017-12-01T09:17:17.088Z","comments":true,"path":"archives/index.html","permalink":"http://litxiaosa.me/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-01T10:30:30.315Z","updated":"2017-12-01T10:30:30.308Z","comments":true,"path":"categories/index.html","permalink":"http://litxiaosa.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-01T13:34:36.015Z","updated":"2017-12-01T12:42:08.595Z","comments":true,"path":"tags/index.html","permalink":"http://litxiaosa.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot（五）之 统一异常处理","slug":"SpringBoot（五）之 统一异常处理","date":"2017-12-05T06:27:18.000Z","updated":"2017-12-05T07:29:55.473Z","comments":true,"path":"2017/12/05/SpringBoot（五）之 统一异常处理/","link":"","permalink":"http://litxiaosa.me/2017/12/05/SpringBoot（五）之 统一异常处理/","excerpt":"我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 我们写一个一段代码： 1234567891011/** * @author xiaosa */@Controllerpublic class ErrorController &#123; @RequestMapping(\"hello\") public String error() throws Exception &#123; throw new Exception(\"发生错误！！\"); &#125;&#125;","text":"我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 我们写一个一段代码： 1234567891011/** * @author xiaosa */@Controllerpublic class ErrorController &#123; @RequestMapping(\"hello\") public String error() throws Exception &#123; throw new Exception(\"发生错误！！\"); &#125;&#125; 此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。 虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。 创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 1234567891011121314@ControllerAdvicepublic class GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = \"error\"; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject(\"exception\", e); mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125;&#125; 实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Error Handler&lt;/h1&gt; &lt;div th:text=\"$&#123;url&#125;\"&gt;&lt;/div&gt; &lt;div th:text=\"$&#123;exception.message&#125;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动该应用，访问：http://localhost:8080/hello，可以看到如下错误提示页面: 通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（四）之 静态资源和拦截器","slug":"SpringBoot（四）之 静态资源和拦截器","date":"2017-12-05T02:27:18.000Z","updated":"2017-12-05T06:42:23.274Z","comments":true,"path":"2017/12/05/SpringBoot（四）之 静态资源和拦截器/","link":"","permalink":"http://litxiaosa.me/2017/12/05/SpringBoot（四）之 静态资源和拦截器/","excerpt":"本章我们来介绍下SpringBoot对静态资源的支持以及很重要的一个类WebMvcConfigurerAdapter 通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter，重写这个类中的方法可以让我们增加额外的配置","text":"本章我们来介绍下SpringBoot对静态资源的支持以及很重要的一个类WebMvcConfigurerAdapter 通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter，重写这个类中的方法可以让我们增加额外的配置 自定义资源映射addResourceHandlers比如，我们想自定义静态资源映射目录的话，只需重写addResourceHandlers方法即可。 1234567891011121314151617/** * @author xiaosa */@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter&#123; /** * 配置静态访问资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"image/**\").addResourceLocations(\"classpath:/image/\"); super.addResourceHandlers(registry); &#125;&#125; 通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。我们访问自定义image文件夹中的a.jpg 图片的地址为 http://localhost:8080/image/a.jpg addResourceLocations指的是文件放置的目录，addResoureHandler指的是对外暴露的访问路径 页面跳转addViewControllersSpringBoot 中，重写WebMvcConfigurerAdapter中的addViewControllers方法即可达到效果 123456789/** * 页面跳转 * @param registry */@Overridepublic void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"login\").setViewName(\"login\"); super.addViewControllers(registry);&#125; 在这里重写addViewControllers方法，并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这也就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是我们推荐添加自己的MVC配置的方式。 拦截器addInterceptors拦截器在我们项目中经常使用的，这里就来介绍下最简单的判断是否登录的使用。要实现拦截器功能需要完成以下2个步骤： 创建我们自己的拦截器类并实现 HandlerInterceptor 接口 重写WebMvcConfigurerAdapter中的addInterceptors方法把自定义的拦截器类添加进来 第一步：自定义拦截器 1234567891011121314151617181920212223242526@Configurationpublic class InvokingInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; User user = (User)request.getSession().getAttribute(\"user\"); if (user == null) &#123; response.sendRedirect(\"login\"); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 这里我们简单实现了根据session中是否有User对象来判断是否登录，为空就跳转到登录页，不为空就通过。 第二步：重写WebMvcConfigurerAdapter中的addInterceptors方法 12345678910111213/** * 拦截器 * @param registry */@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new InvokingInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/toLogin\",\"/login\"); super.addInterceptors(registry);&#125; 这样拦截器就写完了。 页面登录代码 html: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/meta&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form &gt; &lt;input type=\"text\" id = \"userName\" required=\"required\" placeholder = \"用户名\"/&gt; &lt;input type=\"password\" id = \"password\" required=\"required\" placeholder = \"密码\"/&gt; &lt;button type = \"submit\" id = \"toLogin\" &gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/login.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js: 1234567891011121314151617$(\"#toLogin\").click(function () &#123; $.ajax(&#123; type : \"post\", url : \"/toLogin\", data : &#123; \"userName\" : $(\"#userName\").val(), \"password\" : $(\"#password\").val() &#125;, success : function(data) &#123; if (data.result == \"0\") &#123; window.location.href =\"/learn\"; &#125; else &#123; alert(\"账号密码不能为空！\"); &#125; &#125; &#125;);&#125;) 控制层代码 1234567891011121314151617181920212223242526272829303132333435363738394041@Controllerpublic class IndexController &#123; /** * 登陆 * @param request * @return */ @RequestMapping(value = \"/toLogin\", method = RequestMethod.POST) @ResponseBody public Map&lt;String, String&gt; login(HttpServletRequest request, String userName, String password)&#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); if(!userName.equals(\"\") &amp;&amp; password!=\"\")&#123; User user =new User(userName,password); request.getSession().setAttribute(\"user\",user); map.put(\"result\",\"0\"); &#125;else&#123; map.put(\"result\",\"-1\"); &#125; return map; &#125; @RequestMapping(\"/learn\") public ModelAndView index ()&#123; List&lt;LearnThymeleaf&gt; learnList =new ArrayList&lt;&gt;(); LearnThymeleaf bean =new LearnThymeleaf(\"官方参考文档\",\"Spring Boot Reference Guide\",\"地址1\"); learnList.add(bean); bean =new LearnThymeleaf(\"官方SpriongBoot例子\",\"官方SpriongBoot例子\",\"地址2\"); learnList.add(bean); bean =new LearnThymeleaf(\"龙国学院\",\"Spring Boot 教程系列学习\",\"地址3\"); learnList.add(bean); bean =new LearnThymeleaf(\"潇洒的博客\",\"SpringBoot系列\",\"地址4\"); learnList.add(bean); bean =new LearnThymeleaf(\"程序猿DD\",\"Spring Boot系列\",\"地址5\"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView(\"/index\"); modelAndView.addObject(\"learnList\", learnList); return modelAndView; &#125;&#125; 这样访问的时候，如果未登录就会跳转到login.html页面，而访问 http://localhost:8080/login 不会被拦截。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（三）之 Thymeleaf篇","slug":"SpringBoot（三）之 Thymeleaf篇","date":"2017-12-04T08:07:18.000Z","updated":"2017-12-05T06:36:26.100Z","comments":true,"path":"2017/12/04/SpringBoot（三）之 Thymeleaf篇/","link":"","permalink":"http://litxiaosa.me/2017/12/04/SpringBoot（三）之 Thymeleaf篇/","excerpt":"在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？ Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf（官方推荐） FreeMarker Velocity Groovy Mustache","text":"在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？ Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf（官方推荐） FreeMarker Velocity Groovy Mustache 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates Thymeleaf模版Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;artifactId&gt;&lt;/dependency&gt; 示例页面模板：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;learn thymeleaf&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center;margin:0 auto;width: 500px; \"&gt; &lt;h1&gt;SpringBoot系列&lt;/h1&gt; &lt;table width=\"100%\" border=\"1\" cellspacing=\"1\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;系列名称&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"learn : $&#123;learnList&#125;\"&gt; &lt;td th:text=\"$&#123;learn.author&#125;\"&gt;潇洒&lt;/td&gt; &lt;td th:text=\"$&#123;learn.title&#125;\"&gt;SpringBoot系列&lt;/td&gt; &lt;td th:text=\"$&#123;learn.url&#125;\"&gt;点我&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：通过xmlns:th=”http://www.thymeleaf.org“ 命令空间，将静态页面转换为动态的视图，需要进行动态处理的元素将使用“th:”前缀。 编写controller:123456789101112131415161718192021@Controllerpublic class IndexController &#123; @RequestMapping(\"/\") public ModelAndView index ()&#123; List&lt;LearnThymeleaf&gt; learnList =new ArrayList&lt;&gt;(); LearnThymeleaf bean =new LearnThymeleaf(\"官方参考文档\",\"Spring Boot Reference Guide\",\"地址1\"); learnList.add(bean); bean =new LearnThymeleaf(\"官方SpriongBoot例子\",\"官方SpriongBoot例子\",\"地址2\"); learnList.add(bean); bean =new LearnThymeleaf(\"龙国学院\",\"Spring Boot 教程系列学习\",\"地址3\"); learnList.add(bean); bean =new LearnThymeleaf(\"潇洒的博客\",\"SpringBoot系列\",\"地址4\"); learnList.add(bean); bean =new LearnThymeleaf(\"程序猿DD\",\"Spring Boot系列\",\"地址5\"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView(\"/index\"); modelAndView.addObject(\"learnList\", learnList); return modelAndView; &#125;&#125; 如果直接打开html页面展现下面的内容 但是启动程序后，访问 http://localhost:8080/ 则是展示Controller中的值，做到了不破坏HTML自身内容的数据逻辑分离。 如果报错404， 看一下Thymeleaf是否引入到了maven里。 更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 1234567891011121314151617181920212223242526272829303132333435#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #在展示之前检查模板是否存在。spring.thymeleaf.check-template=true#检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true #模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot (二) 之 配置文件详解","slug":"SpringBoot  (二) 之 配置文件详解","date":"2017-12-04T06:07:18.000Z","updated":"2017-12-05T07:34:01.626Z","comments":true,"path":"2017/12/04/SpringBoot  (二) 之 配置文件详解/","link":"","permalink":"http://litxiaosa.me/2017/12/04/SpringBoot  (二) 之 配置文件详解/","excerpt":"相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在pom.xml中引入模块化的Starter POMs，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。","text":"相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在pom.xml中引入模块化的Starter POMs，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里： 12com.xiaosa.name = \"xiaosa\"com.xiaosa.title = \"SpringBoot\" 然后通过@Value(&quot;${属性名}&quot;)注解来加载对应的配置属性，为了方便我们依然在启动类里写如下代码： 123456789@Value(\"$&#123;com.xiaosa.name&#125;\")private String name;@Value(\"$&#123;com.xiaosa.title&#125;\")private String title;@RequestMapping(\"/\") public String hexo()&#123; return name+\",\"+title; &#125; 我们启动工程输入http://localhost:8080 就可以看到打印了”xiaosa,SpringBoot” 在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置： 123com.xiaosa.name=xiaosacom.xiaosa.title=StringBootcom.xiaosa.desc=$&#123;com.xiaosaname&#125;正在努力学$&#123;com.xiaosa.title&#125; 使用随机数在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 12345678910# 随机字符串com.xiaosa.value=$&#123;random.value&#125;# 随机intcom.xiaosa.number=$&#123;random.int&#125;# 随机longcom.xiaosa.bignumber=$&#123;random.long&#125;# 10以内的随机数com.xiaosa.test1=$&#123;random.int(10)&#125;# 10-20的随机数com.xiaosa.test2=$&#123;random.int[10,20]&#125; 多环境配置我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-test.properties：测试环境 application-prod.properties：生产环境 至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。 如：spring.profiles.active=test就会加载application-test.properties配置文件内容 还可以给不同的环境添加不同的端口属性,例如： 1server.port=8081 按照上面的实验，可以如下总结多环境的配置思路： application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置 application-{profile}.properties中配置各个环境不同的内容 通过命令行方式去激活不同环境的配置,例如： 1spring.profiles.active=dev","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（一）之 快速入门","slug":"SpringBoot（一）之 快速入门","date":"2017-12-01T01:54:26.000Z","updated":"2017-12-04T06:21:56.909Z","comments":true,"path":"2017/12/01/SpringBoot（一）之 快速入门/","link":"","permalink":"http://litxiaosa.me/2017/12/01/SpringBoot（一）之 快速入门/","excerpt":"本系列基于：IDEA、JDK8、SprigBoot1.5.9。通常我们推荐使用JDK8 使用Intellij中的Spring Initializr来快速构建Spring Boot工程初始化Spring Boot项目 点击Create New Project，我们可以看到如下图所示的创建功能窗口。其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址，所以这里创建的工程实际上也是基于它的Web工具来实现的。","text":"本系列基于：IDEA、JDK8、SprigBoot1.5.9。通常我们推荐使用JDK8 使用Intellij中的Spring Initializr来快速构建Spring Boot工程初始化Spring Boot项目 点击Create New Project，我们可以看到如下图所示的创建功能窗口。其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址，所以这里创建的工程实际上也是基于它的Web工具来实现的。 点击Next，等待片刻后，我们可以看到如下图所示的工程信息窗口，在这里我们可以编辑我们想要创建的工程信息。其中， Group 一般是公司名字的反写，也可以自己随意Artifact: 你这个项目叫什么Type可以改变我们要构建的工程类型，比如：Maven、Gradle；Language可以选择：Java、Groovy、Kotlin。 点击Next，进入选择Spring Boot版本和依赖管理的窗口。在这里值的我们关注的是，它不仅包含了Spring Boot Starter POMs中的各个依赖，还包含了Spring Cloud的各种依赖。 我们还可以选择SpringBoot的版本。 这个我们勾选了web，你也可以根据自己的需求勾选。点击Next，进入最后关于工程物理存储的一些细节。最后，点击Finish就能完成工程的构建了。 项目结构 如你所见，项目里面基本没有代码，除了几个空目录外，还包含如下几样东西。 pom.xml：Maven构建说明文件。 DemoApplication：一个带有main()方法的类，用于启动应用程序（关键）。 DemoApplicationTests：一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文。 application.properties：一个空的properties文件，你可以根据需要添加配置属性。 应用入口类 DemoApplication是一个很关键的启动类，程序的入口就是这里,为了演示简单，我们不再新建控制类，而是直接在这个入口类中编写，添加@RestController以及index方法，如下： @SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置。后续讲解原理的时候再深入介绍。 main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。 @RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 启动这个最简单的Web项目，他有三种方法。 DemoApplication的main方法启动，上边个标红的和下面那个标红的是一样的。 使用命令 mvn spring-boot:run”在命令行启动该应用，IDEA中该命令在如下位置： 运行mvn package进行打包时，会打包成一个可以直接运行的 JAR 文件，使用java -jar命令就可以直接运行。 这里是SpringBoot的启动标志 打开浏览器访问http://localhost:8080, 你就能看到页面显示Hello Spring Boot效果了，一个简单的Web的项目就是如此简单。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"学习Git（五）之 搭建Git服务器","slug":"学习Git（五） 之 搭建Git服务器","date":"2017-11-29T08:40:46.000Z","updated":"2017-12-04T03:06:22.665Z","comments":true,"path":"2017/11/29/学习Git（五） 之 搭建Git服务器/","link":"","permalink":"http://litxiaosa.me/2017/11/29/学习Git（五） 之 搭建Git服务器/","excerpt":"在之前的学习中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。","text":"在之前的学习中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器。我是在VMware虚拟机上装了一个CentOS 如果你装的是Ubuntu或者其他的，安装命令可能会不同。这个要注意一下。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git: 1sudo yum install git 如果安装不上可能是网络没配好，找到这个下面这个文件 看一下标红的是不是no,如果是,该为yes。再执行上边那个操作就可以了。 第二步，创建证书： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个。 git和 .ssh/keys是自己手动创建的，我的创建在了root目录下。 创建命令是： 12mkdir gitmkdir .ssh 然后给这个目录对应的权限： 1chmod 700 .ssh/ 再cd .ssh 创建 keys 文件： 1touch keys 然后给这个文件对应的权限 1chmod 600 keys 接着就是把所有的公钥导入了。 第三步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/root/lean.git，在/root目录下输入命令： 1sudo git init --bare lean.git 第四步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： 1git clone git@server:/root/lean.git @server: 对应你们git服务器的ip地址。 剩下的推送就简单了。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（四）之 分支管理","slug":"学习Git（四） 之 分支管理","date":"2017-11-29T02:22:33.000Z","updated":"2017-12-04T03:14:52.371Z","comments":true,"path":"2017/11/29/学习Git（四） 之 分支管理/","link":"","permalink":"http://litxiaosa.me/2017/11/29/学习Git（四） 之 分支管理/","excerpt":"分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！","text":"分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 创建与合并分支首先，我们创建dev分支，然后切换到dev分支, 当然了，要在你本地的仓库目录下： 1git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： 12git branch devgit checkout dev 然后，用git branch命令查看当前分支： 1git branch git branch 命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对demo.txt做个修改，加上 haha 然后提交 12git add demo.txtgit commit -m \"branch test\" 现在，dev分支的工作完成，我们就可以切换回master分支： 1git checkout master 切换回master分支后，再查看一个demo.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： 1git merge dev 合并完成后，就可以放心地删除dev分支了： 1git branch -D dev 删除后，查看branch，就只剩下master分支了： 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的 准备新的feature1分支，继续我们的新分支开发： 1git checkout -b feature1 再次修改demo.txt, 增加： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 12git add demo.txtgit commit -m \"AND simple\" 切换到master分支： 1git checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把demo.txt文件的最后一行替换为: 1Creating a new branch is quick &amp; simple 提交 12git add demo.txt git commit -m \"&amp; simple\" 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1git merge feature1 果然冲突了！Git告诉我们，demo.txt文件存在冲突，必须手动解决冲突后再提交。我们可以直接查看demo.txt的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 再提交： 12git add demo.txtgit commit -m \"conflict fixed\" 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 最后，删除feature1分支： 1git branch -D feature1 工作完成。 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在``master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 1git remote 或者，用git remote -v显示更详细的信息 1git remote -v 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1git push origin master 如果要推送其他分支，比如dev，就改成： 1git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1git clone https://github.com/Litxiaosa/learnGit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 1git branch 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，(我们在里面添加了hello world)然后，时不时地把dev分支push到远程： 123git add demo.txtgit commit -m \"add hello world\"git push origin dev 可能让你输入你的GitHub的用户名和密码 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送,我们添加了一句：hello git 123git add demo.txtgit commit -m \"add hello git\"git push origin dev 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 1git pull origin dev git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push。 因此，多人协作的工作模式通常是这样： 首先，可以试图用 git push origin branch-name 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用 git push origin branch-name 推送就能成功！ 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 git branch 查看当前分支 git branch -v 查看每一个分支的最后一次提交 git branch -a 查看本地和远程分支的情况 git branch –merged 查看已经与当前分支合并的分支 git branch –no-merged 查看已经与当前分支未合并的分支 git branch -r 查看远程分支 git branch dev 创建分支 dev git checkout dev 切换到分支dev git checkout -b dev 创建并切换分支dev git merge dev 名称为dev的分支与当前分支合并 git branch -d dev 删除分支dev","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（三） 之 远程仓库","slug":"学习Git（三） 之 远程仓库","date":"2017-11-28T09:58:43.000Z","updated":"2017-12-04T03:43:30.216Z","comments":true,"path":"2017/11/28/学习Git（三） 之 远程仓库/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（三） 之 远程仓库/","excerpt":"Git本地操作的熟练了后，就可以尝试连接远程仓库了，完全可以自己搭建一台运行Git的服务器，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交，不过现阶段，我们不打算这么搞。目前国内外比较出名的提供Git仓库远程托管的有国外的GitHub，国内的开源中国以及coding。这里我以GitHub为例子介绍如何操作远程仓库。","text":"Git本地操作的熟练了后，就可以尝试连接远程仓库了，完全可以自己搭建一台运行Git的服务器，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交，不过现阶段，我们不打算这么搞。目前国内外比较出名的提供Git仓库远程托管的有国外的GitHub，国内的开源中国以及coding。这里我以GitHub为例子介绍如何操作远程仓库。 现在的情景是，你已经在本地创建了一个Git仓库，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。 添加远程仓库 首先，登陆GitHub，然后，在右上角找到“new repository”按钮，创建一个新的仓库： 在Repository name填入learnGit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learnGit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的GitRepository仓库下运行命令： 1git remote add origin git@github.com:Litxiaosa/learnGit.git 请千万注意，把上面的Litxiaosa替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上 1git push -u origin master 可以看到，你本地的代码就推送到远程仓库了推送成功后 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令 1git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 从远程库克隆我们讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库 1sudo git clone https://github.com/Litxiaosa/gitskills.git 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 小结 要关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git 关联后，使用命令 git push -u origin master 第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令 git push origin master 推送最新修改","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（二）之 暂存区","slug":"学习Git（二）之 暂存区","date":"2017-11-28T08:55:30.000Z","updated":"2017-12-04T03:49:30.821Z","comments":true,"path":"2017/11/28/学习Git（二）之 暂存区/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（二）之 暂存区/","excerpt":"工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。","text":"工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的GitRepository文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面说了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 撤销操作 如果你文件只是在工作区修改了，但是还没提交到暂存区的时候，你可以用下面的命令来撤销。 1git checkout -- [file] 比如，你有一个文件叫demo.txt, 里面的内容为：Today is Tuesday。 并且这句话已经提交到暂存区。 此时，你又在工作区修改了demo.txt 这个文件， 内容增加了一句：I don&#39;t know what to say 然后执行git checkout -- demo.txt命令,你会发现demo.txt内容又变成Today is Tuesday了。 1git checkout -- demo.txt git checkout -- file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。 假如你文件在工作区修改了,并且也执行 git add 命令提交给暂存区了，但是，还没有执行commit操作。那么执行上面的 git checkout -- [file] 已经无效了，因为工作区跟暂存区已经一样了，再怎么覆盖内容也一样，这时候就应该使用 git reset HEAD 命令来撤销。 1git reset HEAD demo.txt 还记得如何丢弃工作区的修改吗？ 1git checkout -- demo.txt 回头看看添加的内容是不是又回滚了？ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（一）之 快速入门","slug":"学习Git（一）之 入门","date":"2017-11-28T06:14:43.000Z","updated":"2017-12-04T04:29:00.398Z","comments":true,"path":"2017/11/28/学习Git（一）之 入门/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（一）之 入门/","excerpt":"本系列文章基于Mac系统 之前自己搭建博客的时候使用到GitHub，需要使用git进行版本控制，现在很多公司也在使用Git，发现Git很棒，于是学习了解一下Git。这只是我自己的学习笔记，如果你是大神，请你不吝赐教，如果你也是小白，希望这系列文章能帮到你。","text":"本系列文章基于Mac系统 之前自己搭建博客的时候使用到GitHub，需要使用git进行版本控制，现在很多公司也在使用Git，发现Git很棒，于是学习了解一下Git。这只是我自己的学习笔记，如果你是大神，请你不吝赐教，如果你也是小白，希望这系列文章能帮到你。 安装并配置Git 要使用Git，第一步当然是安装Git了。 首先，打开终端输入一下命令，看你是否安装了Git 1git --version 如果没有安装，那么请下载安装 Git客户端， 选择你自己的系统下载安装即可。 当安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name 你的名字git config --global user.email 你的邮箱 如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不使用 --global 选项的命令来配置。 检查配置信息 如果你不确定你的信息是不是配置成功了，可以输入一下命令查看 1git config --list 如果你觉得返回的信息太多，也可以输入git config &lt;key&gt;： 查询指定的配置，例如: 12git config user.name git config user.email 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录，直接新建文件夹即可（我的起名字叫：GitRepository），然后cd 到该文件夹下，执行下面的命令 1git init 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 提交文件到版本库上面把git仓库搭建好了，现在就来试试添加文件到版本库里面。 创建一个txts文档起名叫做demo.txt，往里面添加一点内容 Hello Git 注意:这里需要文件是UTF-8格式的。 一定要放到GitRepository目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： 1git add demo.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： 1git commit -m \"first commit\" -m 参数是用来注释你提交的信息的，这样以后才知道这次提交更改了什么 查看当前新增或者修改的文件实际使用中你不止提交一个文件，或新增或修改多个文件，可能时间一久就忘了有多少文件需要提交。 这里模拟一下，首先新建一个hello.txt的文件，然后修改demo.txt内容，添加一句come on 这样就有2个文件需要提交了。 我们使用git status命令来查看当前状态,是否有未提交的文件 1git status 如图，可以看到一个demo.txt被修改过了，但还没有准备提交的修改，另外一个是Untracked files: hello.txt，表示新增的文件。 这时候准备把上面2个文件都提交，使用命令: 12git add demo.txtgit add hello.txt 或者你嫌弃文件太多，一次次add感觉很麻烦，那么可以试试使用`git add .`` 提交，.表示提交当前目录所有文件 12git add .git commit -m \"second commit\" 提交后再使用git status命令查看下 如图，可以看到文件提交到仓库了，并且git status后提示nothing to commit, working directory clean，说明当前没有需要提交的修改，工作目录是干净。 查看历史提交记录有时候你想看看之前提交的历史纪录~那么就需要使用到下面的命令： 1git log 如图，可以看到我们提交的2次历史，first commit和 second commit。历史纪录是根据时间倒叙排列的。 如果觉得代码太多了，加点过滤就行 1git log --pretty=oneline 回滚版本现在我们准备把demo.txt回退到上一个版本，也就是“first commit”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交2c49a55···9a9a13c（注意我的提交ID和你的肯定不一样）， 就是上图中那一大长串字符，上一个版本就是 HEAD^，上上一个版本就是 HEAD ^^，当然往上100个版本写 100个^ 比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“second commit”回退到上一个版本“first commit”，就可以使用git reset命令： 1git reset --hard HEAD^ 看看第二次提交的 helllo.txt 是不是不见了，demo.txt 里面的内容是不是也变了？ 好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个second commit的commit id是2c49a55···9a9a13c，于是就可以指定回到未来的某个版本： 1git reset --hard 2c49a5503041f562e8dfbf 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 果然， 老子又回来了！ 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ Git提供了一个命令git reflog用来记录你的每一次命令： 1git reflog （注：我没有再次做回滚操作） commit id 又出来了，现在，你又可以到未来了。就问你厉不厉害！ 结束语好了，这一篇，我们学了Git的安装和一些基本命令操作，差不多算入门了，接下去就是继续深入学习了。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"姑苏有钟声","slug":"姑苏有钟声","date":"2017-10-31T03:51:28.000Z","updated":"2017-12-04T02:16:11.478Z","comments":true,"path":"2017/10/31/姑苏有钟声/","link":"","permalink":"http://litxiaosa.me/2017/10/31/姑苏有钟声/","excerpt":"如果你听歌可眼红，何以待她好偏不懂。","text":"如果你听歌可眼红，何以待她好偏不懂。 她不会像白富美那样偶尔流露出一丝惹人厌的高傲，更不会像女屌丝那样做派发指 长相抱歉。 她在自己生活的圈子里优雅的生活，不会默默无闻。 她长得不算差，打扮得干干净净，或许不会穿的跟颁奖礼一般，但绝对会扬长避短穿出别有一番韵味。她更绝不会不自量力搭配没品。 她或许温婉，或许贤良，或许天真，或许任性，但这都不重要，重要的是，她很温暖，很安心。 可能她是你的同学，又或者是校友，又或者是陌生人，反正就在那个电光火石般的一瞬，你像一朵青春萌动的少年，看见让自己眼前一亮的女生，一种莫名的冲动，发自内心，倚仗着荷尔蒙喷薄而出。 你像一般电视剧演的那样，像一个侦探一样，调动了一切手段渠道，用此处略去七十八个字儿的方法彻底地认识了她。 上天会怜悯那些绞尽脑汁的虔诚孩子，他会轻易地突破第四维度，将两条平行线改变了轨迹，交在了一起。 你只知道在继续省略十万八千个字之后她会叫你傻逼会叫你神经病，会在你让她早点睡觉的时候跟你说嗯。 在你寂寞的单身的想要恋爱的时候，你会发现她总会匪夷所思地出现在你的脑海。 她或许不会天天叫你早睡早起不要熬夜，或许也不记得有纪念意义的日子，或许更不会记得你的生日，你的爱好，她也不会认识太多你身边的朋友，或许连相熟也称不上。但你会。 有时候你也会约她，她大多会欣然答应，但恪守本分，不远不近保持着距离，若即若离。 你开始期待甚至盼望每天与她的相见，就像陈小春唱的，她像个天仙，她太美了。我那么平凡…… 然后小灯泡一亮，叮得一声：她不讨厌我，肯定喜欢我～ 傻逼了吧。 也许对于她来说，你只是一个可有可无的存在，多一个不多，少一个不少。这只是她的一种教养，一个习惯，或者一种本能而已。你不能否认就是有这样的姑娘，自带女神光环，她们能让周围的人都如沐春风，让异性为之深深地吸引。 你跟她身边其余的异性一样，就像女生面对淘宝满屏的东西，你不能说她讨厌你，但确实也挑不到喜欢的。 每个男生骨子里爆棚的自信心也最容易高估自己，而这些恰恰会让感觉良好的少年们自作多情自不量力自欺欺人自讨苦吃自掘坟墓自食其果自取灭亡自作孽不可活。 你把这个感觉转嫁到了她身上，开始无可救药地以为爱上了。 你开始为了她的每句话揣测推断，开始去思考她每一条状态每一个签名，即使像今天我出去玩的好开心如此这般的毫无意义。 你开始每天守在电脑前，看着她的头像亮起来，然后去跟她闲扯去逗她笑，尽所能地去让你开心，快乐。你每次看到冰冷的屏幕上出现她打出来的哈哈或者嘿嘿，你总是盯着屏幕傻呵呵地咧嘴笑。你会反复在脑海里意淫般地勾画出你们俩个人在一起的情形。 你会抵挡不住见她的冲动不在乎跑多少公里，看到她的时候你会觉得这几千公里跟孙猴子一个筋斗那样不值一提。你会挖空心思地对她好，好到用语言描述出来都略显单薄但是无用。好到连你们周围的人都感觉到窒息，直到后来你才知道，太把优柔寡断投鼠忌器的磨叽当慎重的人，往往却会栽到自作聪明作茧自缚这几个字上。 小黄人喜欢的不是apple，而是banana。 对了，你是不是还会像个护食的汪星人一般，假如别的男生若是和她多聊几句，就在脑子里无数次描绘那男的被爆菊的惨状。 你看，说你神经病你还不愿意，你这就是神经病。 你还时常感谢上苍，他把两条平行线交汇在一起。但这只会让你记得交汇那一瞬她蹦蹦跳跳像个小猴子般的身影，和你脑子里那被风吹起的刘海。 你来到她的城市，走过她来时的路，然后，相交线就会渐行渐远。 到这里，你心里一定会跟千万只草泥马奔腾而过一样吧，老天爷办事儿，远他妈的不是你想的路数。 在我收集的剪报里，有大致如下几段话：你那时应该知道，如果一个人真的爱你，她一定会告诉你，至少会表现出来，而不是让你自己胡乱猜测的被感觉左右。和这位姑娘相处，本身就是一件很美好的事。你只是没给自己留一点可进退的余地，后悔莫及。你因为一厢情愿，搭上了自己的一片真心。没人不怪你看不透，只是因为你太需要爱。当你明白你再怎么做也无力回天的时候，还是感觉这东西害了你。这位姑娘对你没感觉，而感觉是个奇妙和淘气的小家伙。 当你觉得一个人千般好万般好，那也许是迷恋。当你觉得她有时候很呆傻，但却傻的非常可爱，那可能是喜欢。当你看到她的每一面，包括最差的，但还不想离开她，那大概是习惯。爱没法去描述，但你永远不会错认。 爱就是内心的召唤而已，夜里睡不着想到她时那满心酸楚的悸动，跟她说话聊天字斟句酌的计较，面对她的时候那喷薄而出的欲望，都是爱情的原因。 那时有一个姑娘，懂你所有，出现在你的生命里。 只是错误的时间，错误的地点，遇到错误的人，却产生了对的感觉。 只是她身上的温暖蛊惑了你，让你误以为那就是爱情。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/tags/不知所云/"}]},{"title":"阿里巴巴Java开发规约插件","slug":"阿里巴巴Java开发规约插件","date":"2017-10-25T03:44:41.000Z","updated":"2017-12-04T02:17:10.465Z","comments":true,"path":"2017/10/25/阿里巴巴Java开发规约插件/","link":"","permalink":"http://litxiaosa.me/2017/10/25/阿里巴巴Java开发规约插件/","excerpt":"阿里巴巴Java开发手册在介绍这款插件之前，先说一下《阿里巴巴Java开发手册》。2017年初，阿里巴巴官方首次公开Java代码规范标准手册，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本，我第二时间（刚公开时我不知道。我也很无奈啊）下载来看。对我个人而言帮助挺大的，渐渐改掉了我好多编码的坏习惯。这个手册的愿景是这样的： “统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本”。","text":"阿里巴巴Java开发手册在介绍这款插件之前，先说一下《阿里巴巴Java开发手册》。2017年初，阿里巴巴官方首次公开Java代码规范标准手册，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本，我第二时间（刚公开时我不知道。我也很无奈啊）下载来看。对我个人而言帮助挺大的，渐渐改掉了我好多编码的坏习惯。这个手册的愿景是这样的： “统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本”。 到现在为止已经更新迭代了三个版本。也是阿里官方对外发布的最后一个PDF版本，我觉得是值得收藏的。 插件简单介绍阿里巴巴基于手册内容，研发了一套自动化的IDE检测插件（IDEA、Eclipse）， 该插件在扫描代码后，将不符合《手册》的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能，提升代码质量，提高团队研发效能。 代码已经开源，GitHub：https://github.com/alibaba/p3c 插件简单教程打开 IDEA 搜索”alibaba”, 你就可以看到返回结果里有”Alibaba Java Coding Guidelines”。我这里已经下载过了。直接安装重启编译器就好， 在项目上右键就可以看到这两个功能，点绿色按钮就扫面本项目全部的文件，如果只想扫描当前的文件，那就在当前文件上右键，那么它只扫描当前的文件。 前面说的都是手动监测，该插件也提供了实时监测的功能，此功能是默认开启的，在你编写代码时就会实时监测，一旦有不符合规范的语句就会出现错误提示。 扫描代码后，不符合规约的代码会按Blocker/Critical/Major三个等级显示在下方面板中，左边是扫描出的不符合规范的代码，依次点进去可以看到是代码的多少行出现了规约问题以及哪一个规约问题，右边则是规约的详细描述及实例代码。不仅如此，右边还可以点击自动改正代码，但是并不是所有的问题都可以。有些还是需要手动改的。 结束语用了几天，说一下感受，总体而言对于我个人而言还是有帮助的，它可以帮助我慢慢改掉我编码中的坏习惯，帮助我在编码规范方面成长。那么用了它是不是会让我们代码少一些bug呢？很显然不是，它只是一个监测和提示工具。最后还得靠我们自己。 多说一句，该插件所用的是阿里巴巴公司的开发规范，肯定会与其他的规范有出入。如果觉得不适合公司或者自己的开发习惯，那就没必要用了。适合自己的最好。","categories":[{"name":"编码规范插件","slug":"编码规范插件","permalink":"http://litxiaosa.me/categories/编码规范插件/"}],"tags":[{"name":"编码规范插件","slug":"编码规范插件","permalink":"http://litxiaosa.me/tags/编码规范插件/"}]},{"title":"solr的配置和简单应用","slug":"solr的配置和简单应用","date":"2017-08-24T02:48:25.000Z","updated":"2017-12-04T04:31:38.438Z","comments":true,"path":"2017/08/24/solr的配置和简单应用/","link":"","permalink":"http://litxiaosa.me/2017/08/24/solr的配置和简单应用/","excerpt":"本文基于solr-6.6 、 tomcat-9、 jdk-1.8 solr下载完成以后解压即可。 在tomcat上安装solr 把solr目录下的server/solr-webapp/webapp目录拷贝到tomcat/webapps的目录下,并且重命名为solr（任意名字）","text":"本文基于solr-6.6 、 tomcat-9、 jdk-1.8 solr下载完成以后解压即可。 在tomcat上安装solr 把solr目录下的server/solr-webapp/webapp目录拷贝到tomcat/webapps的目录下,并且重命名为solr（任意名字） 将solr\\server\\lib\\ext下的所有jar包，以及sol\\server\\lib下以metrics开头的jar包复制到tomcat\\webapps\\solr\\WEB-INF\\lib下 在tomcat\\webapps\\webapp\\WEB-INF中，新建classes文件夹，将solr\\server\\resources下的log4j.properties文件拷贝到里面，修改里面的solr.log=输出日志的路径（请使用/分割，注意不要有中文，避免乱码问题） 将solr\\server中的solr目录拷贝到任意地方，重命名为solrHome 修改tomcat\\webapps\\solr\\WEB-INF中的web.xml文件 并且注释调以下代码 启动tomcat访问localhost:8080/solr/index.html 目前solrHome目录是空的，我们在solrHome目录下创建一个空文件夹core1，这个就是我们的一个实例。 把solr/server/solr下的文件复制到solrHome目录下。 在solr的管理控制台界面，添加一个core1 这下就创建成功了一个实例core1 ,注意，如果无法创建core,看一下是否执行了第8步，网上说这是bug Ik中文分词器 下载IK分词器 将ik-analyzer-solr5-5.x.jar这个jar包放入tomcat/webapps/solr/WEB-INF/lib里面( 千万不要复制到tomcat/lib中，这样会找不到lucene的类) 将IKAnalyzer.cfg.xml，ext.dic（搜狗的扩展词库），stopword.dic放在tomcat\\webapps\\solr\\WEB-INF\\classes目录下 打开solrHome/core1/conf/managed-schema文件 添加以下配置 123456&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer type=\"index\" useSmart=\"false\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\" /&gt; &lt;analyzer type=\"query\" useSmart=\"true\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\" /&gt;&lt;/fieldType&gt; 重启tomcat，即可看到text_ik分词 域 插入的文档必须与域相匹配 域，它在solr中有特定的含义，就类似于数据库表中的列 ，规范着写入的数据。我们先来做个例子。 可以看到，这次插入的文档，有id，title。当然，在solr中，每一条记录都必须有着一个唯一的id，它就类似数据库中的主键，不可重复。这条记录的插入是成功的。 但是，如果我把title改成title1,这就与定义的字段不一样了，就会报错,可以看到，这里提示，未知的字段 title1. 域的定义 field 先拿出来一条配置来看一下 1&lt;field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" /&gt; 首先，我们认识一下这些属性 name: 域名type: 域的类型，必须匹配类型，不然会报错indexed: 是否要做索引stored: 是否要储存required: 是否必填multiValued：是否多值，如果设置为多值，里面的值就会采用数组的方式储存 动态域 dynamicField 同样，我们拿出一条来看 1&lt;dynamicField name=\"*_i\" type=\"string\" indexed=\"true\" stored=\"true\" multiValued=\"true\" /&gt; 那么，什么是动态域呢？就是这个域的名称，是由表达式组成的，只要名称满足了这个表达式，就可以用这个域 同样的认识一下这些属性 name: 域的名称，该域的名称是通过一个表达式来指定的，只要符合这这个规 则，就可以使用这个域 type: 对应的值类型，相应的值必须满足这个类型，不然就会报错indexed: 是否要索引stored: 是否要存储…其它的属性与上边的一致 主键域 uniqueKey 1&lt;uniqueKey&gt;id&lt;/uniqueKey&gt; 指定一个唯一的主键，每一个文档中，都应该有一个唯一的主键，这个值不要随便改 复制域 copeField 12&lt;copyField source=\"cat\" dest=\"text\"/&gt; &lt;field name=\"text\" type=\"string\" indexed=\"true\" stored=\"true\" multiValued=\"true\"/&gt; source: 源域dest: 目标域 复制域，将源域的内容复制到目标域中 注意：目标域必须是允许多值的，如下，multiValued必须为true，因为可能 多个源域对应一个目标域，所以它需要以数组来存储 域的类型 同样的给出一段配置 12345678910111213141516&lt;fieldType name=\"text_general\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer class=\"solr.StandardTokenizerFactory\"/&gt; &lt;filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" /&gt; &lt;!-- in this example, we will only use synonyms at query time &lt;filter class=\"solr.SynonymFilterFactory\" synonyms=\"index_synonyms.txt\" ignoreCase=\"true\" expand=\"false\"/&gt;--&gt; &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer class=\"solr.StandardTokenizerFactory\"/&gt; &lt;filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" /&gt; &lt;filter class=\"solr.SynonymFilterFactory\" synonyms=\"synonyms.txt\" ignoreCase=\"true\" expand=\"true\"/&gt; &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt; &lt;/analyzer&gt;&lt;/fieldType&gt; 介绍一下这些属性 name: 域的名称class: 指定solr的类型analyzer: 分词器的配置type: index(索引分词器)，query(查询分词器)tokenizer: 配置分词器filter: 过滤器 所有上述域，都可以在solrHome/core1/conf/managed-schema文件里找到。 字段的实际配置首先，打开solrHome/core1/conf/managed-schema文件 我们用field来配置实际的业务字段 上边我们配置了中文分词器，已经配置了一个fieldType的中文分词，所 以我们现在一律用中文分词的域类型 主键的id就不需要配置了，默认已经把id配置为主键了 1&lt;field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" /&gt; 商品名称(需要分词，需要存储) 1&lt;field name=\"product_name\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt; 商品图片(不需要分词，需要存储) 1&lt;field name=\"product_url\" type=\"string\" indexed=\"false\" stored=\"true\"/&gt; 商品价格(不需要分词，需要存储) 1&lt;field name=\"product_price\" type=\"double\" indexed=\"false\" stored=\"true\"/&gt; 商品分类(不需要分词，需要存储) 1&lt;field name=\"product_type\" type=\"int\" indexed=\"false\" stored=\"true\"/&gt; 商品描述(需要分词，需要存储) 1&lt;field name=\"product_description\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt; 复制域的应用 用户在搜索框搜索的时候，有可能输入的是商品名称，也有可能输入的是商品描述，也有可能输入的是一个商品类型，那么这些值的搜索，肯定在后台是对应一个域的，那么既然如此，我们就可以把这些域合并成一个，这样在后台只需要单独的对这一个域进行搜索就可以了。 先定义一个目标域： 1&lt;field name=\"aim\" type=\"text_ik\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/&gt; 复制域，把商品名称，商品描述，商品类型名称复制到上面的这个域中 123&lt;copyField source=\"product_name\" dest=\"aim\"/&gt;&lt;copyField source=\"product_type\" dest=\"aim\"/&gt;&lt;copyField source=\"product_description\" dest=\"aim\"/&gt; dataimport 导入数据库数据solr默认是没有开启dataimport这个功能的，所以我们要经过一点配置来开启它 首先找到solr/dist/solr-dataimporthandler-6.6.0.jar，把这个文件复制到tomcat/webapp/solr/WEB-INF/lib/下(前面拷贝过的忽略此操作)。并且找到相应数据库的驱动包，也同样放到该目录。我这里用的是mysql 的驱动 找到solrHome/core1/conf/solrconfig.xml，并打开，在里面添加一段内容 12345&lt;requestHandler name=\"/dataimport\" class=\"solr.DataImportHandler\"&gt; &lt;lst name=\"defaults\"&gt; &lt;str name=\"config\"&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 找到solr/example/example-DIH/solr/db/conf/db-dataconfig.xml，把其复制到solrHome/core1/conf/下，并改名为data-config.xml, 打开并编辑，修改如下 1234567891011121314151617&lt;dataConfig&gt;&lt;!--这是mmysql的配置--&gt;&lt;dataSource driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/solr\" user=\"你的账号\" password=\"你的密码\"/&gt;&lt;document&gt;&lt;!-- name属性，就代表着一个文档，可以随便命名 --&gt;&lt;!-- query是一条sql，代表在数据库查找出来的数据 --&gt;&lt;entity name=\"product\" query=\"select * from product\"&gt; &lt;!-- 每一个field映射着数据库中列与文档中的域，column是数据库列，name是solr的域(必须是在managed-schema文件中配置过的域才行) --&gt; &lt;field column=\"id\" name=\"id\"/&gt; &lt;field column=\"name\" name=\"product_name\"/&gt; &lt;field column=\"url\" name=\"product_url\"/&gt; &lt;field column=\"price\" name=\"product_price\"/&gt; &lt;field column=\"type\" name=\"product_type\"/&gt; &lt;field column=\"description\" name=\"product_description\"/&gt;&lt;/entity&gt;&lt;/document&gt;&lt;/dataConfig&gt; 重启tomcat， 会看到如下页面 点击蓝色的按钮，则开始导入，导入过程依据数量量的大小，需要的时间也不同，可以点击右边的Refresh status来刷新状态，可以查看当前导入了多少条 solrJ的使用现在说一下使用solrj来维护solr的索引及操作，solrj就是一个java的客户端，是一个jar包的使用，首先引入MAVEN的依赖，solrj的版本号要对应solr的版本号 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;6.6.0&lt;/version&gt;&lt;/dependency&gt; 增加及修改 在solr中，增加与修改都是一回事，当这个id不存在时，则是添加，当这个id存在时，则是修改 123456789101112131415161718192021public class SolrController &#123; private String serverUrl = \"http://10.60.20.152:8080/solr/core1\"; public void save() throws SolrServerException, IOException &#123; //创建 HttpSolrClient client = new HttpSolrClient(serverUrl); SolrInputDocument doc = new SolrInputDocument(); doc.addField(\"id\", \"5008\"); doc.addField(\"product_name\", \"姓名\"); doc.addField(\"product_type\", \"1\"); doc.addField(\"product_url\", \"图片\"); doc.addField(\"product_price\", \"11\"); doc.addField(\"product_description\", \"这是一个测试例子\"); client.add(doc); client.commit(); client.close(); &#125;&#125; 删除索引 1234567891011121314151617181920212223242526public class SolrController &#123;private String serverUrl = \"http://10.60.20.152:8080/solr/core1\";public void delete()throws Exception&#123; HttpSolrClient client = new HttpSolrClient(serverUrl); //1.删除一个 client.deleteById(\"5008\"); //2.删除多个 List&lt;String&gt; ids = new ArrayList&lt;&gt;(); ids.add(\"1\"); ids.add(\"2\"); client.deleteById(ids); //3.根据查询条件删除数据,这里的条件只能有一个，不能以逗号相隔 client.deleteByQuery(\"id:5008\"); //4.删除全部，删除不可恢复 client.deleteByQuery(\"*:*\"); //一定要记得提交，否则不起作用 client.commit(); client.close(); &#125;&#125; 查询 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SolrController &#123;private String serverUrl = \"http://10.60.20.152:8080/solr/core1\";public void search()throws Exception&#123; HttpSolrClient client = new HttpSolrClient(serverUrl); //创建查询对象 SolrQuery query = new SolrQuery(); //q 查询字符串，如果查询所有*:* query.set(\"q\", \"product_name:潇洒\"); //fq 过滤条件，过滤是基于查询结果中的过滤 query.set(\"fq\", \"product_type:1\"); //sort 排序，请注意，如果一个字段没有被索引，那么它是无法排序的 //query.set(\"sort\", \"product_price desc\"); //start row 分页信息，与mysql的limit的两个参数一致效果 query.setStart(0); query.setRows(10); //fl 查询哪些结果出来，不写的话，就查询全部、 // query.set(\"fl\", \"\"); //df 默认搜索的域 query.set(\"df\", \"product_keywords\"); //高亮设置 //开启高亮 query.setHighlight(true); //高亮域 query.addHighlightField(\"product_name\"); //前缀 query.setHighlightSimplePre(\"&lt;span style='color:red'&gt;\"); //后缀 query.setHighlightSimplePost(\"&lt;/span&gt;\"); //执行搜索 QueryResponse queryResponse = client.query(query); //搜索结果 SolrDocumentList results = queryResponse.getResults(); //查询出来的数量 long numFound = results.getNumFound(); System.out.println(\"总查询出:\" + numFound + \"条记录\"); //遍历搜索记录 //获取高亮信息 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : results) &#123; System.out.println(\"商品id:\" + solrDocument.get(\"id\")); System.out.println(\"商品名称 :\" + solrDocument.get(\"product_name\")); System.out.println(\"商品分类:\" + solrDocument.get(\"product_type\")); System.out.println(\"商品价格:\" + solrDocument.get(\"product_price\")); System.out.println(\"商品描述:\" + solrDocument.get(\"product_description\")); System.out.println(\"商品图片:\" + solrDocument.get(\"product_url\")); //输出高亮 Map&lt;String, List&lt;String&gt;&gt; map = highlighting.get(solrDocument.get(\"id\")); List&lt;String&gt; list = map.get(\"product_name\"); if(list != null &amp;&amp; list.size() &gt; 0)&#123; System.out.println(list.get(0)); &#125; &#125; client.close();&#125;&#125; 补充 q - 查询字符串，如果查询所有: (id:1)fq - （filter query）过虑查询，过滤条件，基于查询出来的结果fl - 指定返回那些字段内容，用逗号或空格分隔多个start - 分页开始rows - 分页查询数据sort - 排序，格式：sort=+[,+]… 。示例：（score desc, price asc）表示先 “score” 降序, 再 “price” 升序，默认是相关性降序。fl表示索引显示那些field(表示所有field,如果想查询指定字段用逗号或空格隔开（如：Name,SKU,ShortDescription或Name SKU &gt;ShortDescription【注：字段是严格区分大小写的】）)hl 是否高亮 ,如hl=truehl.fl 高亮field ,hl.fl=Name,SKUhl.simple.pre 高亮前面的格式hl.simple.post 高亮后面的格式","categories":[{"name":"solr","slug":"solr","permalink":"http://litxiaosa.me/categories/solr/"}],"tags":[{"name":"solr","slug":"solr","permalink":"http://litxiaosa.me/tags/solr/"}]},{"title":"浮生若梦","slug":"浮生若梦","date":"2017-07-17T02:44:52.000Z","updated":"2017-12-04T02:16:53.452Z","comments":true,"path":"2017/07/17/浮生若梦/","link":"","permalink":"http://litxiaosa.me/2017/07/17/浮生若梦/","excerpt":"浮生若梦,若梦非梦,浮生何如,如梦之梦 ——— 庄子《如梦之梦》 你现在二十五六岁，大学毕业两三年，或者差不多研究生刚毕业。你有着一份还算凑合的工作，天天宅在冷气十足的办公室里，每个月拿到手的钱，交了房租吃了饭，所剩无几。","text":"浮生若梦,若梦非梦,浮生何如,如梦之梦 ——— 庄子《如梦之梦》 你现在二十五六岁，大学毕业两三年，或者差不多研究生刚毕业。你有着一份还算凑合的工作，天天宅在冷气十足的办公室里，每个月拿到手的钱，交了房租吃了饭，所剩无几。 每天晚上六点半，当时钟跳过员工手册上写着的下班时间，你从来不会有任何的反应。 离开校园上班不过两三年，你已经写成了一套属于自己的作息节奏： 你每天晚上七点下楼，去楼下的小餐馆来一碗重庆小面吸嗦满嘴是油；七点半你上楼继续坐在办公桌前干活；你心里想着，妈蛋怎么都没有人下班，真是一群神经病；殊不知你也可能一不留神成为另一个人心中的神经病；九点半，你终于收拾东西，回到你的出租房。 你躺在床上，辗转反侧，寂寞难眠，你总觉的你一天什么事情都没干，青春不是应该释放激情与梦想吗？怎么看起来那么颓废。你盘算着明天就辞职，然后去自驾游，去看海，去隐居，但想到银行卡的余额，你呵呵呵呵呵笑起来，还是算了吧！ 那些曾经的同学们都开始结婚了。你在微信里收到了一条条设计华丽带着动画和音乐的婚礼邀请函。你一边用没时间婉拒着他们的婚礼邀请，一边感叹，卧槽这么早就结婚了。 你想找个人谈恋爱，可是你还没准备好，在你的生命中出现另外一个人是多么的累。你根本就忘记了如何去爱。 你说你满怀理想，你文艺青年，你从来觉得在农家菜馆聚餐点一桌子毛血旺是一件很low的事情，你从来都厌恶一群人的娱乐生活只有去洗脚、按摩、打麻将、去KTV唱爱情买卖。 你觉得你想要的生活绝不是这样。 你穷，你却喜欢健身，喜欢吉他、喜欢巴洛克音乐与延时摄影，你坚持去健身，你坚持去听独立歌手的演出，你坚持读书。你就是这么的逼格甚高，但你每天都过得好不快乐。 你一直还是认为爱情是件很美好的事情，你一定要找到那个对的人，你没有主动去追逐某些人，你相信缘分。然而现在，你已经失去了好多的机会，你身边的异性们，一个个脱离单身，而你，却只能假装用”不讲究“的理由默默承受着焦虑。 当然，更悲剧的是，每天的枯燥的工作，和虚无缥缈的理想追求，占据了你大量的思考的时间，你已经习惯了你现在的状态。单身，对你来说是一个安全的保护区，你根本不敢去突破你的保护区，你觉得你根本没经济接受你的生命中多出来的那个人。 你一无所有，在大城市里你没有房子和车子，你没有时间，没有喜欢的人，没有理想；你离家千里，你忘了自己当时为什么路途遥遥来到这里，住在这租来的小房子里，却每天只是为了在这里睡上一觉。 其实你一直觉得自己还很年轻。你才毕业两三年，你在任何的职业发展中都只是一个初级的小白。可是你却发现，一切都变得和以前完全不一样了，见到好久不见老朋友，你不会再和他互骂傻逼，不会再和他深夜饮酒不醉不归，不会再和他骑行百公里，只为去想去的地方看一看大海。如今的你，和他一壶清茶，聊起的话题，都是关于工作、婚姻和财富自由。你终于变成了你以前所讨厌的那个能在众人面前谈笑风生好几个小时，讲着一个丑的不行的PPT自嗨的不行的那个人。 你从未想过，这一切，居然变得那么快。 你身边的朋友，买车了、买房了、辞职了、环游世界了、家里拆迁了、创业了融资了、结婚了。每一天，你的内心都在经受着来自他人的波澜。你无奈，你沮丧，你迷失了自己。在你的出租房的公用卫生间里，刷牙洗脸，你看着墙壁上镜子中的自己：又丑又穷；一口漱口水吐掉之后，你终于自言自语对自己说：“难怪没有人喜欢我”。 那么，然后呢？ 就这样随波逐流，还是做出改变，还是坚持自我呢？ 人生如戏，或者是孤独地像条狗，或者是假装合群扮小丑，都是你自己的选择。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/tags/不知所云/"}]},{"title":"风景旧曾谙","slug":"风景旧曾谙","date":"2017-06-30T02:41:15.000Z","updated":"2017-12-04T02:19:40.022Z","comments":true,"path":"2017/06/30/风景旧曾谙/","link":"","permalink":"http://litxiaosa.me/2017/06/30/风景旧曾谙/","excerpt":"七月将至， 天气慢慢炎热而躁动。来杭州已九月有余。 初来杭州，怀着美好的憧憬一心想去走走，看许仙和白娘子相遇的断桥，看充满神话色彩的雷峰塔。看济公修行之地灵隐寺等等。 然而始终未曾迈出一步。一来公司996累成狗，二来无人同行，感觉会少很多乐趣。","text":"七月将至， 天气慢慢炎热而躁动。来杭州已九月有余。 初来杭州，怀着美好的憧憬一心想去走走，看许仙和白娘子相遇的断桥，看充满神话色彩的雷峰塔。看济公修行之地灵隐寺等等。 然而始终未曾迈出一步。一来公司996累成狗，二来无人同行，感觉会少很多乐趣。 上班、吃饭、下班、睡觉的机械日子就这样慢慢过去了。 人嘛，总会厌烦浑浑噩噩的生活，我开始买了很多书，东野圭吾的，三毛的，韩寒的，余华的等等。开始充实自己，除了代码外，我开始享受这些，不说提高什么，觉得比下班打游戏看电视有意义些。 说起健身，还是合租的一个姑娘带我去的。她说要去减肥，我说，走，我也去，我要去增肥。她鄙视我说等我真的增肥成功了，想减肥就难了。然而，一个月过去了，我体重一毛没增加。但是胳膊和胸部的肌肉稍微有一丢丢凸显了。这也是成果。不能急，我相信胸肌会有的，腹肌也会有的。 换了公司，自由时间也多了。慢慢培养起来的爱好和习惯，更有时间和理由去坚持了，决定出去走走，把刚来杭州的憧憬，一点点实现。 不为别的，我只是不想满足于现状。 和朋友扯淡的时间慢慢少了，有时偶尔聊起天来，他们会说，最近跟灭绝了似的。“哈哈。是的，我在努力提高自己，寻找我的意中人 ”我笑。 可能是代码写多了，感觉世界的逻辑有时很简单。 事情无非是let，变化历历 或者是const，永恒安息 如果一开始就想清楚，留不住的就随风去，不会变的就钉到骨子里。那你说多轻松。 打雷了，杭州的天总是这样，大太阳说下雨就下雨，也凉快了不少。 偌大的杭州，一个人独来独往。不过每一天过的也很充实。江南好， 风景旧曾谙。我喜欢。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/tags/不知所云/"}]},{"title":"MAC下配置环境变量","slug":"MAC下配置环境变量","date":"2017-06-25T02:29:23.000Z","updated":"2017-12-04T04:33:30.252Z","comments":true,"path":"2017/06/25/MAC下配置环境变量/","link":"","permalink":"http://litxiaosa.me/2017/06/25/MAC下配置环境变量/","excerpt":"配置JAVA环境变量大家在windows里面配置JDK环境变量很容易，但是如果要在mac里面配置JDK环境变量和windows里面有所不同,虽然Mac自带有jdk,但是版本比较低。我们讲的是自己下载的jdk。 jdk的下载路径， Library:就是资源库 1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home","text":"配置JAVA环境变量大家在windows里面配置JDK环境变量很容易，但是如果要在mac里面配置JDK环境变量和windows里面有所不同,虽然Mac自带有jdk,但是版本比较低。我们讲的是自己下载的jdk。 jdk的下载路径， Library:就是资源库 1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home 打开配置文件 .bash_profile 1open .bash_profile 如果没有 .bash_profile 创建文件后打开 1touch .bash_profile 把下面的代码复制进去, 注意替换成你的jdk版本 12345export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Homeexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport $JAVA_HOME/bin:$PATH: 然后保存并退出 .bash_profile 输入下面的命令使修改生效 1source .bash_profile 使用如下命令查看环境变量是否已经配置成功： 1echo $JAVA_HOME 如果出现下图，说明配置成功了 配置maven环境变量打开终端,输入 1open .bash_profile 输入Maven安装包路径, 注意替换成你的解压路径 123export M2_HOME=/Library/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 保存修改并关闭 .bash_profile 输入 source .bash_profile 使修改生效 输入 mvn -v 验证Maven是否配置成功，如果显示Maven版本信息则配置成功。","categories":[{"name":"环境变量","slug":"环境变量","permalink":"http://litxiaosa.me/categories/环境变量/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://litxiaosa.me/tags/环境变量/"}]},{"title":"hexo绑定域名","slug":"hexo绑定域名","date":"2017-06-24T12:20:38.000Z","updated":"2017-12-04T02:19:59.741Z","comments":true,"path":"2017/06/24/hexo绑定域名/","link":"","permalink":"http://litxiaosa.me/2017/06/24/hexo绑定域名/","excerpt":"因为Hexo个人博客是托管在github之上，每次访问都要使用githubyourname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。","text":"因为Hexo个人博客是托管在github之上，每次访问都要使用githubyourname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。 购买域名国内国外有很多的域名供应商，选择一个好的机构购买域名，我是在阿里的万网购买的。通过搜索找到自己喜欢的域名，然后加入清单，然后去付款就好了。 现在你的域名还处于sever状态，你需要去实名认证，上传你的身份证正面照就好了，官方说3～5个工作日，不过我的一天就认证好了。 然后你需要进行域名解析。进入阿里云控制台 点击域名，进入下图页面 点击解析 记录类型选择:CNAME主机记录选择：*记录值： 你的github博客网址 ,我的是litxiaosa.github.io hexo 添加CNAME文件这些全部设置完成后，此时你并不能要申请的域名访问你的博客，接着你需要做的是在blog根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：litxiaosa.me 然后等几分钟访问一下吧。 安装畅言评论系统现在你已经有了域名和备案了，那么我们就可以安装畅言评论系统了，这里是畅言官方网站。注册账号，去认证，备案，这里默认这一系列步骤都操作完成了。 然后我们登陆账号，进入后台，下面有个畅言秘钥。 由于该主题没有集成畅言评论，所以我们得自己配置,在_yelee/layout/_partial/comments 文件夹中新建一个 changyan.ejs 的文件，把上边那个代码拷贝进去，然后appid替换成你的appid， conf替换成你的appKey。添加 红色框住的代码。保存。 进入 layout/_partial/article.ejs 文件， 添加一下代码 12&lt;% &#125; else if (theme.changyan.on) &#123; %&gt; &lt;%- partial('comments/changyan') %&gt; 进入 _config.yml 根目录 添加下面的配置。 部署线上，就看到添加的评论系统了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"安装和配置主题","slug":"安装和配置主题","date":"2017-06-24T07:27:36.000Z","updated":"2017-12-04T04:45:38.257Z","comments":true,"path":"2017/06/24/安装和配置主题/","link":"","permalink":"http://litxiaosa.me/2017/06/24/安装和配置主题/","excerpt":"安装主题hexo 自带的主题略显简单了，这里我们介绍安装yelee主题，你也可以选择其他主题，只是把路径改成你想安装主题的路径就好了，进入你之前创建的文件夹下，执行下面的命令 1git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 等它克隆好了以后，你就会看到你的文件夹下/themes多了一个yelee文件夹","text":"安装主题hexo 自带的主题略显简单了，这里我们介绍安装yelee主题，你也可以选择其他主题，只是把路径改成你想安装主题的路径就好了，进入你之前创建的文件夹下，执行下面的命令 1git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 等它克隆好了以后，你就会看到你的文件夹下/themes多了一个yelee文件夹 切换主题修改根目blog根目录下的 _config.yml 修改主题设置接下来，让我们看看主题的配置文件吧。进入yelee目录，打开该目录的 _config.yml ,这里是我配置的。都有中文注释，应该可以看懂的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301# Theme Version | 当前版本Yelee: \"3.5\"# &gt;&gt;\" Basic Setup | 基础设置 &lt;&lt;&lt;# Header | 主菜单## About Page: `hexo new page about`## Tags Cloud Page: `hexo new page tags`menu: 主页: / 所有文章: /archives/ #随笔: /tags/随笔 标签云: /tags/ 关于我: /about/# Link to your avatar | 填写头像地址avatar: /img/头像.jpg# Small icon of Your site | 站点小图标地址favicon: /站点小图标.jpg# Internationalization | 主题语言## Change Language in SITE's _config.yml | 在站点配置中切换语言## https://hexo.io/docs/internationalization.html## Available Languages: en, zh-Hans, zh-Hant-TW, zh-Hant-HK# Subdirectory | 子目录## If your site' url is 'http://yoursite.com/blog', set root_url as '/blog/'## 网站若存放在子目录，请按上面格式填写## https://hexo.io/docs/configuration.html#URLroot_url:# Year of Site Creation | 网站成立年份since: 2017# Social info. Bar | 社交信息展示## Keep \"mailto:\" in Email | 设置 Email 时保留 \"mailto:\"## Encrypt email 加密邮件地址 http://ctrlq.org/encode/## RSS requires a plugin to take effect | 使用 RSS 需先安装对应插件## https://github.com/hexojs/hexo-generator-feedsubnav: #Email: \"mailto:123@123.com\" 新浪微博: \"\" GitHub: \"\" #V2EX: \"#\" #RSS: \"/atom.xml\" 知乎: \"\" #豆瓣: \"douban\" #简书: \"jianshu\" #SegmentFault: \"\" #博客园: \"cnblogs\" #CSDN: \"\" #Coding: \"\" #网易云音乐: \"netease\" #虾米音乐: \"xiami\" #bilibili: \"\" #AcFun: \"\" #niconico: \"\" #Quora: \"\" #Facebook: \"#\" #Google: \"#\" #Twitter: \"#\" #LinkedIn: \"#\" #QQ: \"#\" #微信: \"Wechat\" #PayPal: \"#\" #StackOverflow: \"#\" #CodePen: \"\" #Plunker: \"\" #Instagram: \"#\" #LOFTER: \"\" #Flickr: \"#\" #reddit: \"\" #Medium: \"\" #TiddlyWiki: \"\" #Tumblr: \"\" #_500px: \"\"# &gt;&gt;&gt; Conments 评论系统 &lt;&lt;&lt;# Chose ONE as your comment system and keep others disable.# 选一个作为网站评论系统，其他保持禁用。preload_comment: true## false: 当点击评论条等区域时再加载评论模块## false: load comment's section until u click/hover on the bar/iconshow_count: false## 是否在主页文章标题旁显示评论数（多说、Disqus）## Add comment count after article titledisqus: #on: true shortname: # https://help.disqus.com/customer/en/portal/articles/466208-what-s-a-shortname- # It is unnecessary to enable disqus here if # you have set \"disqus_shortname\" in your site's \"_config.yml\"duoshuo: #on: true domain: # 是否开启多说评论，http://duoshuo.com/create-site/ # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分 # http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)youyan: #on: true id: # 是否开启友言评论，http://www.uyan.cc/index.php # id 中填写你的友言用户数字ID，注册后进入后台管理即可查看 # 友言服务在 Web 环境下运行，普通本地环境无法查看，请部署后在线上测试。# &gt;&gt;&gt; Style Customisation 样式自定义 &lt;&lt;&lt;# Background | 背景## \"5\": show images form bg-1.jpg to bg-5.jpg in `/yelee/source/background/`## \"5\": 显示`/yelee/source/background/`文件夹中 bg-1.jpg 到 bg-5.jpg 这5张图片## \"0\": white-gray background | 淳朴灰白背景background_image: 5# Base Font Size | 字号调节base_font_size: 16 #px, 16 - 24## General Color Scheme | 主题配色方案## 可用值 Value: yiliacolor_scheme:highlight_style: on: true inline_code: 2 # Value: 0 - 9 可选 code_block: 0 # Value: 0 - 4 # Set inline_code to style highlight text # Chose a highlight theme for code block # 通过 inline_code 切换内置文本高亮样式 # 通过 code_block 切换内置代码高亮配色主题blockquote_style: on: true blockquote: 3 # Value: 0 - 7 可选 # 自定义文章「引用部分」的样式# Headings Style | 标题风格## 0-Yelee, 1-Yilia, 2-GitHubheading_style: 0 # Value: 0 - 2## List style type (ul) | 无序列表项标记样式list_style: 0 # value: 0 - 12 可选# 左边栏宽度 pxleft_col_width: 300# Copyright info. of post | 文末版权信息copyright: false# Table of contents | 文章目录toc: on: true list_number: true # 目录序号 max_depth: 5 # 1 - 6 (h1-h6) 目录最大级数 nowrap: false # Keep title on same line | 目录标题不换行# 是否开启主页及加载头像时的动画效果# Animation in Homepage and Loading avataranimate: true# Load jQuery UI to style tooltips# 工具提示框样式美化jquery_ui: true# Max width of right cloumn | 限制右侧内容的宽带limit_article_width: on: false max_width: 60 # em# &gt;&gt;&gt; Small features | 小功能设置 &lt;&lt;&lt;# 是否开启边栏多标签切换# Birdhouse button in left columntagcloud: true# Blogroll, Link exchange | 友情链接#friends: #Hexo: https://hexo.io #GitHub: https://pages.github.com/ #MOxFIVE: http://moxfive.xyz/friends: true#是否开启“关于我”。aboutme: #aboutme: true# Open link in a new tab | 是否在新窗口打开链接## `global` 0: Set separately, 1: Open all in new 2: Open all in current## `global` 0: 分开设置, 1: 全部在新标签打开, 2: 全部在\"当前\"标签打开open_in_new: global: 0 # 0-2 title: false # article title in homepage 主页文章标题 post: true # link within post/page 正文中的链接 tags: false # 标签 categories: false # 分类 article_nav: false # 导航 archives: false # 归档 mini_archives: false # 迷你归档 menu: false # 边栏菜单 friends: true # 友情链接 socail: false # 社交图标# Customize feed link 自定义订阅地址rss: /atom.xml# Update Reminder for IE6/7/8# 针对 IE6/7/8 的升级浏览器提示ie_updater: on: true link: //outdatedbrowser.com/ ## http://browsehappy.com/ ## http://outdatedbrowser.com/# Tab Title Change | 标签页标题切换tab_title_change: on: true left_tab_title: '(つェ⊂) 我藏好了哦~ ' return_tab_title: '(*´∇｀*) 被你发现啦~ '# &gt;&gt;&gt; Vendors | 第三方工具 &amp; 服务 &lt;&lt;&lt;# Local Site Search | 本地站内搜索## Insatall below plugin to take effect | 使用搜索需先安装对应插件## https://github.com/PaicHyperionDev/hexo-generator-searchsearch: on: true onload: false ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus# images viewer | 图片浏览器## http://www.fancyapps.com/fancybox/fancybox: true# Display Math(LaTeX, MathML...) | 数学公式支持## https://www.mathjax.org/mathjax: true# Socail Share | 是否开启分享share: on: true baidu: true addthis: false addthis_pubid: ## Go to www.addthis.com/dashboard to get your pubid (in src of Code) ## and customize AddThis share buttons# 百度、谷歌站长验证。填写 HTML 标签 content# Site Verification for Google and Baidu. HTML label content.baidu_site:google_site:# Fill in Google Analytics tracking ID, #e.g. UA-XXXXX-Xgoogle_analytics:# 百度统计 http://sitecenter.baidu.com/sc-web/# 查看代码，填入 //hm.baidu.com/hm.js? 之后的内容baidu_tongji: #填入 //hm.baidu.com/hm.js? 之后的内容# 不蒜子网站计数设置# http://ibruce.info/2015/04/04/busuanzi/visit_counter: on: true site_visit: true page_visit: true# GitHub Repo Widget# https://github.com/hustcc/GitHub-Repo-Widget.jsgithub_widget: false# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: on: true type: \"minimal\" # Keep Quotes | 保留引号避免出错 color: blueCDN: jquery: //cdn.bootcss.com/jquery/2.2.4/jquery.min.js require: //cdn.bootcss.com/require.js/2.2.0/require.min.js fontawesome: //cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css fancybox_js: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css animate_css: //cdn.bootcss.com/animate.css/3.5.1/animate.min.css jquery_ui_js: //cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js jquery_ui_css: //cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css pace_js: //cdn.bootcss.com/pace/1.0.2/pace.min.js clipboard: //cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js mathjax: //cdn.bootcss.com/mathjax/2.6.1/MathJax.js scrollreveal: //cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js blog根目录下的 _config.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 潇洒的博客subtitle: 隔岸无旧情，姑苏有钟声。description: 喜欢看书，对吉他有点小兴趣，专注JAVA。author: 潇洒language:timezone: #网站时区。Hexo 默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://litxiaosa.meroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writingnew_post_name: :title.md # File name of new posts # 新建文章默认文件名default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tab # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: true #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: true #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章highlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:Litxiaosa/Litxiaosa.github.io.git branch: master 个人头像默认头像存储于 yelee/source/img/avatar.png，你可以替换你想要的图片，也可以上网上的图片链接. HTTPS事项如果你的站点通过 HTTPS 访问，那下列的服务可能 无法正常使用： 多说评论友言评论百度分享百度统计 可使用下列支持 HTTPS 的服务替代 Disqus 评论AddThis谷歌分析 文章摘要如果你写的文章过长，全部展示是很难看的，所以在文章里你想折叠的地方可以写 &lt;!-- more --&gt; 标签云页面如果你想开启标签云，在 blog/source 文件夹下新建一个 tags 文件夹 ，里面新建一个 index.md 的文件，然后把下面的内容拷进去 1234layout: tagstitle: tags --- 本地站内搜索使用搜索需先安装对应插件，用于生成索引数据,执行下面的命令 1npm install hexo-generator-search --save 然后，在你的主题 _config.ymd 文件里, 改为 on: true即为启用搜索 123search: on: true onload: false onload: true : 索引数据 search.xml 随页面一起加载 [效率优先] onload: false : 当激活搜索框时再下载索引数据 [按需加载] 站点小图标若将图标存储 yelee/source/favicon.png,则配置中对应填写 /favicon.png，另外填网络图片的地址也可 1favicon: /favicon.png 结果如下： 网页背景图背景图文件所在路径: /yelee/source/background/ themes/yelee/_config.yml 背景参数:background_image: 5默认值为5，可按需修改“5”: 设置/yelee/source/background/文件夹中 bg-1.jpg 到 bg-5.jpg 这5张图片为背景“0”: 取消网页背景图，使用淳朴的灰白主题","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"hexo+github搭建自己的个人博客","slug":"hexo-github搭建自己的个人博客","date":"2017-06-24T02:01:03.000Z","updated":"2017-12-04T04:42:07.061Z","comments":true,"path":"2017/06/24/hexo-github搭建自己的个人博客/","link":"","permalink":"http://litxiaosa.me/2017/06/24/hexo-github搭建自己的个人博客/","excerpt":"由于个人电脑是Mac, 所以这里就以Mac OS为参考，其实Mac跟windows搭建博客差别不大，如果用windows的朋友觉得不适，请移步之嘟嘟MD的独立博客，有详细的windows平台下的教程。嗯，那我们开始吧。","text":"由于个人电脑是Mac, 所以这里就以Mac OS为参考，其实Mac跟windows搭建博客差别不大，如果用windows的朋友觉得不适，请移步之嘟嘟MD的独立博客，有详细的windows平台下的教程。嗯，那我们开始吧。 安装Git点击进入git官网，下载安装包，然后按步骤安装就好。可以输入下面的命令查看git是否安装成功。 1git --version 安装 Node.js点击进入 node.js官网，一个是通用版，一个是最新版，选择一个下载，然后按步骤安装。 安装hexo 下载安装hexo 1npm install -g hexo 安装好以后，在终端输入： 1hexo 如果出现下图，则说明安装成功： 初始化博客 建立一个博客的文件夹,blog是文件夹名字，可以根据自己的喜好定义 1hexo init blog 然后进入该文件夹 1cd blog 运行node.js 命令，根据博客默认的配置安装必要的依赖包 1npm install 初始化完成后，我们可以看到博客的文件夹 那么基本的搭建过程就完成了，让我们看看效果吧，这里介绍几个命令。 12345hexo clean #清理缓存，如果你改动了东西，没有效果，试试这个命吧。hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章 在你的终端 hexo目录下执行下面的命令 12hexo g hexo s 然后浏览器访问http://localhost:4000, 此时，你应该看到你的博客了。当然了，这个博客只是本地的，别人是看不到了，你需要把它放到github上。 注册github账号如果您已有github账号，请跳过，进入github进行注册，邮箱和密码请记好。 创建repository repository就相当于一个仓库，存放你代码的地方，点击 new repository 填写你的项目名字repository name, 这个名字格式要为youname.github.io, 例如我的xiaosa.github.io, 填写完以后点击下面的 creat创建。 部署本地项目到github上 编辑它，在_config.yml最下方，添加如下配置(记得改成自己的。另外记得一点，hexo的配置文件中任何’:’后面都是带一个空格的) github是你之前创建仓库的地址，可以通过下图获得 然后保存它，如果你是第一次使用github或者使用过但是没有配置过SSH,可能你需要配置一下，可以检查一下是否已经存在SSH Keys 1~/.ssh/ .ssh文件为隐藏文件，需要先设置隐藏文件可见才可以看到。 如果不存在，输入下面的命令创建。 1ssh-keygen -t rsa -C \"你注册github的邮箱\" 一路回车就好，这个不需要设置密码，因为这个Key仅仅用于简单的服务，完成后输入命令打开 id_rsa.pub 1cat ~/.ssh/id_rsa.pub 然后你就会得到最后面含有你邮箱的公钥，复制它。去你的github下。 title随便写，把复制的公钥粘贴到key里。点下面的add SSH key。好了。基本配置就完了。下面我们把我们的代码传到 github上，在终端输入 12hexo ghexo d 如果执行hexo d 报下面的错误 就先安装一下hexo-deployer-git,再执行 hexo d 1npm install hexo-deployer-git --save 至此，我们的项目就部署到github上了。 那么，访问博客的链接是什么呢？ 点击标注的Settings,往下拉，如果你看到的是这样的。那么点击那个 None，选择第一个，点save. 访问你博客的链接就出来了，去访问试试吧！ 发表文章既然博客搭建好了，就发表一下文章看看效果吧。hexo中写文章使用的是Markdown，语法不难，看一下就会了。然后去下载一个Markdown的编辑器，很多，看个人喜好。 在终端的blog路径下输入 1hexo new \"my new post\" 然后就会在你 blog/source/_posts 下生成一个 .md 的文件，以后你的文章就存放到这里，你也可以直接在这里新建一个 .md 的文件。写完文章后，你可以使用 hexo g 命令生成静态文件， 然后hexo s 进行本地预览。感觉没问题了，hexo d 上传到github上吧。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2017-06-24T01:01:03.000Z","updated":"2017-12-04T02:17:50.410Z","comments":true,"path":"2017/06/24/HelloWorld/","link":"","permalink":"http://litxiaosa.me/2017/06/24/HelloWorld/","excerpt":"","text":"在嘟嘟MD技术博客的帮助下，属于我自己的博客终于搭建起来了！ 折腾了好几天，在github page上看到自己的博客加载下来时，油然而生的成就感，兴奋了半上午。期间也踩了不少的坑，再一次感谢嘟嘟MD的指导。是的，它不是QQ空间，不是微博，也不是贴吧，它是属于自己的一个块小小的领地，所以我满足于这种归属感。 学编程时输入的第一个词语就是hello world！它更是一种象征。那第一篇文章就献给你吧。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://litxiaosa.me/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://litxiaosa.me/tags/随笔/"}]}]}