{"meta":{"title":"潇洒的博客","subtitle":"一个Java码农，喜欢看书，对吉他有点小兴趣。","description":null,"author":"潇洒","url":"http://litxiaosa.me"},"pages":[{"title":"archives","date":"2018-01-08T10:08:59.038Z","updated":"2017-12-01T09:17:17.088Z","comments":true,"path":"archives/index.html","permalink":"http://litxiaosa.me/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-08T10:08:59.042Z","updated":"2017-12-01T10:30:30.308Z","comments":true,"path":"categories/index.html","permalink":"http://litxiaosa.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-08T10:08:59.040Z","updated":"2017-12-01T12:42:08.595Z","comments":true,"path":"tags/index.html","permalink":"http://litxiaosa.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo静态博客部署到腾讯云","slug":"hexo静态博客部署到腾讯云","date":"2018-03-08T07:33:34.000Z","updated":"2018-03-08T10:00:23.575Z","comments":true,"path":"2018/03/08/hexo静态博客部署到腾讯云/","link":"","permalink":"http://litxiaosa.me/2018/03/08/hexo静态博客部署到腾讯云/","excerpt":"年后的第一篇博客，又回到了说hexo上，去年申请的阿里云服务器快要到期了，对于我这种赤贫的人来说，买一个感觉老贵了。正好最近腾讯云在搞活动，就买了一年的，虽然是最低配置，对于我个人用足够了。 既然要弃用阿里云，那么我去年部署到阿里云的静态博客就要重新部署到腾讯云了，正好借着这个机会，写一个部署的大致流程，以防自己以后又换云服务器的时候忘了怎么部署。哈哈。 这里我们默认你有台云服务器，并能正常使用。","text":"年后的第一篇博客，又回到了说hexo上，去年申请的阿里云服务器快要到期了，对于我这种赤贫的人来说，买一个感觉老贵了。正好最近腾讯云在搞活动，就买了一年的，虽然是最低配置，对于我个人用足够了。 既然要弃用阿里云，那么我去年部署到阿里云的静态博客就要重新部署到腾讯云了，正好借着这个机会，写一个部署的大致流程，以防自己以后又换云服务器的时候忘了怎么部署。哈哈。 这里我们默认你有台云服务器，并能正常使用。 云服务器端的配置Nginx配置 ssh连接服务器 下载Nginx以及依赖库 123456a. yum install pcre -y yum install pcre-develb. yum install zlib-develc. yum install gd-devel openssl-devel -yd. yum install gcce. wget http://nginx.org/download/nginx-1.12.2.tar.gz 解压Nginx 1tar -zxvf nginx-1.12.2.tar.gz 校验需要的模块,如果你想添加更多模块，在后边加上即可。这里我也没有设置用户，用的默认的root用户 1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module 预编译以及正式安装 123makemake install 这样我们就把Nginx安装完成了，前面的步骤我们可以看出，我安装在了 /usr/local 目录下。 启动并验证是否安装成功 那怎么确定，我的Nginx安装成功了呢？我们可以启动Nginx访问一下。 12/usr/local/nginx/sbin/nginxwget http://127.0.0.1 如果出现如下，则说明安装配置成功。 也可以在浏览器中输入你的服务器的公网IP 建立仓库 我们要把本机的静态化页面提交到服务器的Git仓库里。这里我们创建一个仓库。 建立代码仓库, 这里我在home目录下创建一个git文件夹 123456mkdir gitcd /home/git //nginx网站要指向/home/git中mkdir hexo.gitgit init --bare hexo.git //这一步是建立裸仓库，如果你的这一步报没有git，请安装git。chown -R 755 /home/git //给权限 755表示赋予权限访问，-R：递归，就是在这个文件夹下的所有文件夹以及文件全部修改。 将本地机器的ssh公钥传到 home/git/.ssh目录下, ls -a可以查看隐藏目录。 12cd /home/gitmkdir .ssh 打开你本机的终端， 输入如下命令 1scp /Users/xiaosa/.ssh/id_rsa.pub root@118.25.7.207:/home/git/.ssh/authorized_keys /Users/xiaosa/.ssh/id_rsa.pub: 我本机的公钥地址路径， /home/git/.ssh/：放到的服务器的地址路径。 authorized_keys： 文件名。 配置Nginx 查找Nginx配置文件, 并打开该配置文件。 1nginx -t 我的配置文件位在： /usr/local/nginx/conf/nginx.conf 打开后如下图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 修改http下的server， 加一个 root /home/git; 123456789101112server &#123; listen 80; server_name localhost; root /home/git; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; 按一下 esc 然后 shift+两下字母z 就是 shift+zz 保存并退出。 重启Nginx服务器 1/usr/local/nginx/sbin/nginx -s reload 实现自动部署自动部署是通过Git钩子实现的接下来，在服务器上的裸仓库 hexo.git 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /home/git。 在第二步建立的裸仓中（即hexo.git文件夹中），找到hooks目录新建一个post-update文件 1vi post-update 把下面的一段添加进去，然后保存并退出 1git --work-tree=/home/git --git-dir=/home/git/hexo.git checkout -f 修改权限让其可执行 1chmod +x post-update 部署hexo本地站点配置文件中修改： 123deploy: type: git repo: root@118.25.7.207:/home/git/hexo.git 最后，就可以成功地把你的博客迁移到腾讯云啦～","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"SpringBoot集成ElasticSearch","slug":"SpringBoot集成ElasticSearch","date":"2018-01-10T05:34:43.000Z","updated":"2018-01-11T01:32:05.401Z","comments":true,"path":"2018/01/10/SpringBoot集成ElasticSearch/","link":"","permalink":"http://litxiaosa.me/2018/01/10/SpringBoot集成ElasticSearch/","excerpt":"前面的几篇都是简单的配合和操作，没有在项目中使用，本文我们来介绍 SpringBoot如何集成ElasticSearch，把ElasticSearch应用到实际的项目中去。 我们新建一个SpringBoot项目，这里SpringBoot的一些知识我就不介绍了。 引入elasticsearch的依赖","text":"前面的几篇都是简单的配合和操作，没有在项目中使用，本文我们来介绍 SpringBoot如何集成ElasticSearch，把ElasticSearch应用到实际的项目中去。 我们新建一个SpringBoot项目，这里SpringBoot的一些知识我就不介绍了。 引入elasticsearch的依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.6.5&lt;/version&gt;&lt;/dependency&gt; 创建config类 可以利用postman 测试， 输入：localhost:端口号/elasticSearch/方法名 12345678910111213141516171819202122 /** * 搜索引擎ES的config * @author xiaosa */@Configurationpublic class ElasticSearchConfig &#123; @Bean public TransportClient client() throws UnknownHostException &#123; ////tcp端口，默认9300 //当时我们配置了三个节点，我们可以new 三个InetSocketTransportAddress，然后都addTransportAddress到里面 InetSocketTransportAddress node = new InetSocketTransportAddress(InetAddress.getByName(\"localhost\"),9300); //初始化一个自定义的配置 Settings settings = Settings.builder() //集群名字，当时我配置的叫xiaosa .put(\"cluster.name\", \"xiaosa\").build(); TransportClient client = new PreBuiltTransportClient(settings); client.addTransportAddress(node); return client; &#125;&#125; controller层 增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 /** * 搜索 * @author xiaosa */@RestController@RequestMapping(\"elasticSearch\")public class ElasticSearchController &#123; @Autowired private TransportClient client; /** * 根据ID查询 * @param id * @return */ @GetMapping(\"/get/people/man\") @ResponseBody public ResponseEntity getPeople(@RequestParam(name = \"id\", defaultValue = \"\") String id)&#123; if (id.isEmpty()) &#123; return new ResponseEntity( HttpStatus.NOT_FOUND); &#125; GetResponse response = this.client.prepareGet(\"people\", \"man\", id).get(); if(response.isExists())&#123; return new ResponseEntity(response.getSource(), HttpStatus.OK); &#125;else &#123; return new ResponseEntity(response.getSource(), HttpStatus.NOT_FOUND); &#125; &#125; /** * 添加 * @param name * @param country * @param age * @param date * @return */ @PostMapping(\"/add/people/man\") @ResponseBody public ResponseEntity addPeople(@RequestParam(name = \"name\") String name, @RequestParam(name = \"country\") String country, @RequestParam(name = \"age\") int age, @RequestParam(name = \"date\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") Date date) try &#123; XContentBuilder content = XContentFactory.jsonBuilder() .startObject() .field(\"name\", name) .field(\"country\", country) .field(\"age\", age) .field(\"date\", date.getTime()) .endObject(); IndexResponse result = this.client.prepareIndex(\"people\", \"man\").setSource(content).get(); return new ResponseEntity(result.getId(), HttpStatus.OK); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * 根据ID删除 * @param id * @return */ @PostMapping(\"/remove/people/man\") @ResponseBody public ResponseEntity removePeople(@RequestParam(name = \"id\") String id)&#123; DeleteResponse result = this.client.prepareDelete(\"people\", \"man\", id).get(); return new ResponseEntity(result.toString(), HttpStatus.OK); &#125; /** * 根据ID更新名字 * @param id * @param name * @return */ @PostMapping(\"/update/people/man\") @ResponseBody public ResponseEntity updatePeople(@RequestParam(name = \"id\") String id, @RequestParam(name = \"name\") String name)&#123; UpdateRequest update = new UpdateRequest(\"people\", \"man\", id); try &#123; XContentBuilder build = XContentFactory.jsonBuilder().startObject(); if(name !=null)&#123; build.field(\"name\", name); &#125; build.endObject(); update.doc(build); UpdateResponse result = this.client.update(update).get(); return new ResponseEntity(result.toString(), HttpStatus.OK); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * 复合查询 * @param name * @param country * @param gtDate * @param ltDate * @return * @PostMapping(\"/query/people/man\") @ResponseBody public ResponseEntity queryPeople(@RequestParam(name = \"name\") String name, @RequestParam(name = \"country\") String country, @RequestParam(name = \"gtDate\") String gtDate, @RequestParam(name = \"ltDate\") String ltDate)&#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); if(name !=null)&#123; boolQuery.must(QueryBuilders.matchQuery(\"name\", name)); &#125; if(country !=null)&#123; boolQuery.must(QueryBuilders.matchQuery(\"country\", country)); &#125; //范围查询 RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(\"date\").from(gtDate); if(ltDate !=null )&#123; rangeQuery.to(ltDate); &#125; boolQuery.filter(rangeQuery); SearchRequestBuilder builder = this.client.prepareSearch(\"people\") .setTypes(\"man\") .setSearchType(SearchType.QUERY_THEN_FETCH) .setQuery(boolQuery) .setFrom(0) .setSize(10); System.out.println(builder); SearchResponse response = builder.get(); List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for (SearchHit hit: response.getHits()) &#123; result.add(hit.getSource()); &#125; return new ResponseEntity(result, HttpStatus.OK); &#125;&#125;","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"http://litxiaosa.me/categories/搜索引擎/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://litxiaosa.me/tags/ElasticSearch/"}]},{"title":"ElasticsSearch 之 高级查询","slug":"ElasticsSearch-之-高级查询","date":"2018-01-10T02:10:14.000Z","updated":"2018-01-10T04:53:37.230Z","comments":true,"path":"2018/01/10/ElasticsSearch-之-高级查询/","link":"","permalink":"http://litxiaosa.me/2018/01/10/ElasticsSearch-之-高级查询/","excerpt":"工具用的PostMan 本文我们来介绍ElasticsSearch的高级查询。 在ES中查询分为子条件查询和复合条件查询 子条件查询：特定字段查询所指特定值 Query context: 在查询过程中，除了判断文档是否满足查询条件外，ES还会计算一个 _score来标示匹配的程度，旨在判断目标文档和查询条件的匹配度。他常用的查询有- 全文本查询：针对文本类型数据 - 字段级别查询： 针对结构化数据， 如：数字、日期等 Filter context: 在查询过程中，只判断该文档是否满足条件，只有Yes 或者 No，没有匹配度。 复合条件查询：一一定的逻辑组合子条件查询","text":"工具用的PostMan 本文我们来介绍ElasticsSearch的高级查询。 在ES中查询分为子条件查询和复合条件查询 子条件查询：特定字段查询所指特定值 Query context: 在查询过程中，除了判断文档是否满足查询条件外，ES还会计算一个 _score来标示匹配的程度，旨在判断目标文档和查询条件的匹配度。他常用的查询有- 全文本查询：针对文本类型数据 - 字段级别查询： 针对结构化数据， 如：数字、日期等 Filter context: 在查询过程中，只判断该文档是否满足条件，只有Yes 或者 No，没有匹配度。 复合条件查询：一一定的逻辑组合子条件查询 全文本查询 它包括：模糊匹配、习语匹配、多个字段的匹配查询、语法的查询。 模糊匹配 地址栏：localhost:9200/people/man/_search 用post方法，搜索以后你会看到，美国队长也出现在搜索结果里。他是匹配了美国和大兵，所有name有美国的就会搜索出来。 1234567&#123; \"query\": &#123; \"match\": &#123; \"name\": \"美国大兵\" &#125; &#125;&#125; 习语匹配 如果我们想匹配美国大兵整个词语呢？ 用match_phrase即可。这样就只会搜索出来 美国大兵的信息。 1234567&#123; \"query\": &#123; \"match_phrase\": &#123; \"name\": \"美国大兵\" &#125; &#125;&#125; 多个字段的匹配查询 你会看到，name 和 country只要包含美国的都会搜索出来。 12345678&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"美国\", \"fields\": [\"name\", \"country\"] &#125; &#125;&#125; 语法查询 我们查询包含中国和美国的数据， OR：关键词 1234567&#123; \"query\": &#123; \"query_string\": &#123; \"query\": \"美国 OR 中国\" &#125; &#125;&#125; 还可以添加更多条件：查询name 和 country包含美国或者中国的数据 12345678&#123; \"query\": &#123; \"query_string\": &#123; \"query\": \"美国 OR 中国\", \"fields\": [\"name\", \"country\"] &#125; &#125;&#125; 字段级别查询 查询出生日期在某个范围内的数据。 gte 和 lte 的意思是包含的意思，如果去掉e 大家可以试一下。我们也可以用 “now” 关键词表示当前时间 12345678910&#123; \"query\": &#123; \"range\": &#123; \"date\": &#123; \"gte\": \"1487-01-01\", \"lte\": \"1998-01-01\" &#125; &#125; &#125;&#125; Filter查询 我们查询国家为英国的数据，主要作用是条件过滤。 1234567891011&#123; \"query\": &#123; \"bool\": &#123; \"filter\": &#123; \"term\": &#123; \"country\": \"英国\" &#125; &#125; &#125; &#125;&#125; 复合条件查询 固定分数查询 我们平常的查询，ES都会给我们一个匹配度 _score字段， 并且基本每个都不一样。我们可以看到_score变成了1 1234567891011&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"match\": &#123; \"name\": \"潇洒\" &#125; &#125; &#125; &#125; &#125; 我们也可以自定义_score ,这里就全部变成2了。 123456789101112&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"match\": &#123; \"name\": \"潇洒\" &#125; &#125;, \"boost\": 2 &#125; &#125; &#125; Booble查询 满足这两个条件其中一个的都会查询出来。关键词：should, 是OR的逻辑。如果把should换成must 再搜一下看看，must是必须满足的意思，AND的逻辑。 1234567891011121314151617&#123; \"query\": &#123; \"bool\": &#123; \"should\": [&#123; \"match\": &#123; \"name\": \"潇洒\" &#125; &#125;, &#123; \"match\": &#123; \"country\": \"英国\" &#125; &#125; ] &#125; &#125; &#125; 还有一个关键词：must_not 意思我搜谁都可以，就是不能搜你！哼 1234567891011 &#123; \"query\": &#123; \"bool\": &#123; \"must_not\": &#123; \"term\": &#123; \"name\": \"袋鼠\" &#125; &#125; &#125; &#125;&#125; 可以看到ES的查询非常灵活，下一节我们介绍与SpringBoot项目的结合。","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"http://litxiaosa.me/categories/搜索引擎/"}],"tags":[{"name":"ElasticsSearch","slug":"ElasticsSearch","permalink":"http://litxiaosa.me/tags/ElasticsSearch/"}]},{"title":"学习ElasticSearch 之 简单的增删改查","slug":"学习Elasticsearch 之 增删改查","date":"2018-01-09T12:36:53.000Z","updated":"2018-01-10T02:12:52.910Z","comments":true,"path":"2018/01/09/学习Elasticsearch 之 增删改查/","link":"","permalink":"http://litxiaosa.me/2018/01/09/学习Elasticsearch 之 增删改查/","excerpt":"本文我们介绍ES的简单的增删改查操作。 插入我们同样使用postman 工具，以下操作都是postman 地址栏：localhost:9200/people/man/1 用post方法 这里的1是索引，我们可以自定义，这是唯一的。 123456&#123; \"name\": \"潇洒\", \"country\": \"中国\", \"age\": 18, \"date\": \"2018-01-01\" &#125;","text":"本文我们介绍ES的简单的增删改查操作。 插入我们同样使用postman 工具，以下操作都是postman 地址栏：localhost:9200/people/man/1 用post方法 这里的1是索引，我们可以自定义，这是唯一的。 123456&#123; \"name\": \"潇洒\", \"country\": \"中国\", \"age\": 18, \"date\": \"2018-01-01\" &#125; 点击send 发送，会出现,表明插入成功 1234567891011121314&#123; \"_index\": \"people\", \"_type\": \"man\", \"_id\": \"1\", \"_version\": 1, \"result\": \"created\", \"_shards\": &#123; \"total\": 2, \"successful\": 2, \"failed\": 0 &#125;, \"_seq_no\": 0, \"_primary_term\": 1 &#125; 刷新之前，我们看在people 下边有个 docs: 0 (0), 刷新以后就变成了 docs: 1 (2)我们点数据浏览，刚刚插入的数据就出现在里面了。 注意：这里data拼错了，拼成了dat了。 我们也可以让ES自己生成ID, 地址栏把代表ID的数字去掉，该用POST提交，其他格式不变，就可以了。 修改例如，我们修改ID为1的数据 地址栏输入：localhost:9200/people/man/1/_update 加上 _update 代表是更新操作。指定post方法 12345&#123;\"doc\":&#123;true\"name\": \"隔岸\" &#125;&#125; 提交以后，刷新head插件就会看到ID为1的数据，被修改了。 删除例如，我们删除ID为1的数据，删除索引是非常危险的事情，建议不要轻易删除 地址栏：localhost:9200/people/man/1 选择DELETE方法 发送以后，数据就删除了。 我们也可以利用head 插件进行删除，比如我们删除之前创建的book, 点击book下面的动作，选择删除。确认一下即可删除。 条件查询在查询操作之前，我事先插入了几条数据，大家也可以按上述插入方法插入数据。 根据ID查询。地址栏：localhost：9200/people/man/你插入的id 用get方法，执行以后数据就被查出来了。 我们还可以用 _search 关键字查询, 用post方法， 所有的条件查询都是用 query 关键字。 match_all：代表查询全部 12345&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 我们也可以增加查询条件, from:代表从哪里返回，size：代表几条数据 1234567&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;, \"from\": 1, \"size\": 5&#125; 关键词查询 ，查询国籍为中国的数据, 数据是根据 _score 倒叙排列的 1234567&#123; \"query\": &#123; \"match\": &#123; \"country\": \"中国\" &#125; &#125;&#125; 我们也可以自定义排序, 按出生日期进行降序排列，你会发现 _score 的值变成null 了，因为我们自定义了排序规则 1234567891011121314&#123; \"query\": &#123; \"match\": &#123; \"country\": \"中国\" &#125; &#125;, \"sort\": [ &#123; \"date\": &#123; \"order\": \"desc\" &#125; &#125; ] &#125; 聚合查询 地址栏：localhost:9200/people/man/_search 依然用post请求， _search 是搜索关键字。 我们根据age 年龄进行聚合查询 aggs: 聚合查询关键字 123456789&#123; \"aggs\": &#123; \"group_by_age\": &#123; \"terms\": &#123; \"field\": \"age\" &#125; &#125; &#125;&#125; 同样的，我们可以多条件聚合查询 1234567891011121314&#123; \"aggs\": &#123; \"group_by_age\": &#123; \"terms\": &#123; \"field\": \"age\" &#125; &#125;, \"group_by_country\": &#123; \"terms\": &#123; \"field\": \"country\" &#125; &#125; &#125;&#125; ES简单的增删改查就介绍到这里，下一节我们说一说高级查询。","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"http://litxiaosa.me/categories/搜索引擎/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://litxiaosa.me/tags/ElasticSearch/"}]},{"title":"学习ElasticSearch 之 配置","slug":"学习Elasticsearch","date":"2018-01-09T04:28:39.000Z","updated":"2018-01-10T02:13:24.927Z","comments":true,"path":"2018/01/09/学习Elasticsearch/","link":"","permalink":"http://litxiaosa.me/2018/01/09/学习Elasticsearch/","excerpt":"本文基于Mac 认识 ElasticSearch 搜索引擎ElasticSearch是一个基于Lucene的搜索服务器。是一个高度可扩展的开源全文搜索和分析引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便，它使您能够快速，实时地存储，搜索和分析大量数据。","text":"本文基于Mac 认识 ElasticSearch 搜索引擎ElasticSearch是一个基于Lucene的搜索服务器。是一个高度可扩展的开源全文搜索和分析引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便，它使您能够快速，实时地存储，搜索和分析大量数据。 相比于solr Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能; Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式； Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供； Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。 Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用 ElasticSearch的基本概念 Cluster和Node： ES可以以单点或者集群方式运行，以一个整体对外提供search服务的所有节点 组成cluster，组成这个cluster的各个节点叫做node。 shard： 通常叫分片，这是ES提供分布式搜索的基础，其含义为将一个完整的index分成若干部分存储在相同或不同的节点上，这些组成index的部分就叫做shard。 Index： 这是ES存储数据的地方，类似于关系数据库的database。 Document type： 类似关系数据库的表，主要功能是将完全不同schema的数据分开，一个index里面可以有若干个Document type。 Document： 这个类似关系数据库的一行，在同一个Document type下面，每一Document都有一个唯一的ID作为区分。 Filed： 类似关系数据库的某一列，这是ES数据存储的最小单位。 Replica： 和replication通常指的都是一回事，即index的冗余备份，可以用于防止数据丢失，或者用来做负载分担。 下载和安装去官网下载，这里我选择的是ZIP,然后解压即可。 启动ElasticSearch 进入到你下载的Elasticsearch文件夹 1sh ./bin/elasticsearch 当你看到started说明启动成功了，然后访问 localhost:9200 下载插件看到这个json格式的数据是不是感觉有点不友好，我们可以下载插件。 下载 elasticsearch-head 下载完成以后解压，终端 cd 到 elasticsearch-head-master 目录下，执行以下命令 1npm install 等他加载完以后，执行启动命令 1npm run start 然后我们访问 localhost:9100 但是，我们发现未连接，所以，我们需要在cd 到 Elasticsearch/config目录下找到 elasticsearch.yml，在最下面增加以下配置，我们可以先停掉两个服务。添加完以后，我们保存并退出， 12http.cors.enabled: truehttp.cors.allow-origin: \"*\" 这个时候，我们可以后台启动，终端cd 到 Elasticsearch目录下。 -d 表示后台启动。 1sh cd ./bin/elasticsearch -d 我们再去开启head 插件，cd 到 elasticsearch-head-master,开启 1npm run start 我们再次访问 localhost:9100, 可以看到连接上了。 我们看到了集群健康值显示的是：green 绿色 ，它还有两个状态： yellow 黄色：它的意思是，集群健康值已经出现问题，但是不影响使用。 red 红色： 它的意思是，集群的健康值已经很差了，虽然会搜索出来数据，但是已经出现丢失数据现象。 分布式安装上边的安装我们介绍的是单台的安装，在实际使用过程中肯定是集群化，那么，我们就尝试搭建集群化的Elasticsearch。我们会搭建三个节点，一个master，就类似于指挥官，两个slave节点 ，就类似于随从。为了操作方便，我们把刚刚搭建的指定为master 我们找到elasticsearch/config 下的 elasticsearch.yml 做一下修改，在之前的配置下面加上这些 个配置，然后我们保存并退出。 12345678#集群的名字cluster.name: xiaosa#master的名字node.name: master#告诉它，它就是masternode.master: true#绑定IPnetwork.host: 127.0.0.1 我们之前 -d 后台启动了一个elasticsearch了，我们这里要把它重启，首先找到它, 杀掉这个进程。 12ps -ef | grep elastickill -9 进程号 然后我们再后台启动，如果你关掉了head 插件的进程的话，请重启插件的进程。 1sh ./bin/elasticsearch -d 去浏览器访问 localhost:9100 ,我们就看到了一个节点 master 我们还可以访问 localhost:9200 去确认我们的配置 下边我们配置两个随从节点，我们在elasticsearch同级目录下，新建一个文件夹叫 el_slave 把我们之前下载的elasticsearch压缩包解压两份到这个文件夹下，一个叫el_slave1 一个叫el_slave2 ,然后各自修改配置。千万不要为了省事，复制你之前配置好的master，会出错。 slave1 我们做如下配置 12345678#集群的名字，这歌要和master的配置一样 cluster.name: xiaosa#slave1的名字node.name: slave1#绑定IPnetwork.host: 127.0.0.1#意思是找到master,否则会找不到他的领导masterdiscovery.zen.ping.unicast.hosts: [\"127.0.0.1\"] slave2 我们做如下配置 12345678#集群的名字，这歌要和master的配置一样 cluster.name: xiaosa#slave2的名字node.name: slave2#绑定IPnetwork.host: 127.0.0.1#意思是找到master,否则会找不到他的领导masterdiscovery.zen.ping.unicast.hosts: [\"127.0.0.1\"] 然后我们保存并退出，各自启动服务。可以看到我们的三个节点都在了。如果你想增加多台，按上述步骤即可。 创建索引 我们可以在 插件的图形化界面中创建索引，点击索引 ——&gt; 创建索引 注意：索引名字必须小写并且不能有下划线 我们在点回概览，你会看到很多数字框框，粗线框的那些是主分片，旁边的那些是分片的备份。 我们可以点击book 下方的信息-索引信息，我们可以看到 mappings里面的内容是空的，这就是非结构话的索引。 那么我们如何创建结构话的索引呢？我们可以点复合查询。写好以后，点击已读，验证JSON,没问题后，点击提交请求。 刷新一下，再点击索引信息，就可以在mappings 里看到你写的结构，这叫结构化索引。 我们也可以用工具进行操作，比如 Postman, 下面我们用postman创建一个people 索引 用put方法 在地址栏里输入 localhost:9200/people, people就是你的索引名字 number_of_shards: 分片数 number_of_replicas 备份数 多种格式请用 || 12345678910111213141516171819202122&#123; \"settings\": &#123; \"number_of_shards\": 3, \"number_of_replicas\": 1 &#125;, \"mappings\": &#123; \"man\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\" &#125;, \"country\": &#123; \"type\": \"keyword\" &#125;, \"age\": &#123; \"type\": \"date\", \"format\": \"yyy-MM-dd HH:mm:ss || yyyy-MM-dd || epoch_millis\" &#125; &#125; &#125; &#125;&#125; 点击发送之后，下边会出来，表明创建成功。我们可以刷新一下head插件查看 { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;people&quot; } 入门就先说到这里，下一节我们说简单的增删改查操作。","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"http://litxiaosa.me/categories/搜索引擎/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://litxiaosa.me/tags/ElasticSearch/"}]},{"title":"如何使用RedisTemplate访问Redis数据结构","slug":"如何使用RedisTemplate访问Redis数据结构","date":"2018-01-05T02:56:31.000Z","updated":"2018-01-05T12:11:31.206Z","comments":true,"path":"2018/01/05/如何使用RedisTemplate访问Redis数据结构/","link":"","permalink":"http://litxiaosa.me/2018/01/05/如何使用RedisTemplate访问Redis数据结构/","excerpt":"Redis 数据结构简介Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合） 下面来对这5种数据结构类型作简单的介绍：","text":"Redis 数据结构简介Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合） 下面来对这5种数据结构类型作简单的介绍： 结构类型 结构存储的值 结构的读写能力 String 可以是字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement) List 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素 Set 包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同 添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素 Hash 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 Zset 字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 Redis 5种数据结构的概念大致介绍到这边，下面将结合Spring封装的RedisTemplate来对这5种数据结构的运用进行演示 RedisTemplate介绍spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api RedisTemplate在spring代码中的结构如下：12345org.springframework.data.redis.coreClass RedisTemplate&lt;K,V&gt;java.lang.Object org.springframework.data.redis.core.RedisAccessor org.springframework.data.redis.core.RedisTemplate&lt;K,V&gt; Type Parameters: K: 模板中的Redis key的类型（通常为String）如：RedisTemplate注意：如果没特殊情况，切勿定义成RedisTemplate，否则根据里氏替换原则，使用的时候会造成类型错误 。 V: 模板中的Redis value的类型 RedisTemplate中定义了对5种数据结构操作12345redisTemplate.opsForValue();//操作字符串redisTemplate.opsForHash();//操作hashredisTemplate.opsForList();//操作listredisTemplate.opsForSet();//操作setredisTemplate.opsForZSet();//操作有序set StringRedisTemplate与RedisTemplate 两者的关系是StringRedisTemplate继承RedisTemplate。 两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据 SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。 RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。 RedisTemplate配置如下：1234567891011121314151617@Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(redisConnectionFactory); template.setKeySerializer(jackson2JsonRedisSerializer); template.setValueSerializer(jackson2JsonRedisSerializer); template.setHashKeySerializer(jackson2JsonRedisSerializer); template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125; Redis的String数据结构 （推荐使用StringRedisTemplate）注意：如果使用RedisTemplate需要更改序列化方式 12345RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer(); template.setKeySerializer(stringSerializer ); template.setValueSerializer(stringSerializer ); template.setHashKeySerializer(stringSerializer ); template.setHashValueSerializer(stringSerializer ); ValueOperations可以对String数据结构进行操作 set void set(K key, V value); 12使用：redisTemplate.opsForValue().set(\"name\",\"tom\");结果：redisTemplate.opsForValue().get(\"name\") 输出结果为tom set void set(K key, V value, long timeout, TimeUnit unit); 12使用：redisTemplate.opsForValue().set(\"name\",\"tom\",10, TimeUnit.SECONDS);结果：redisTemplate.opsForValue().get(\"name\")由于设置的是10秒失效，十秒之内查询有结果，十秒之后返回为null set void set(K key, V value, long offset); 该方法是用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始 1234使用：template.opsForValue().set(\"key\",\"hello world\"); template.opsForValue().set(\"key\",\"redis\", 6); System.out.println(\"***************\"+template.opsForValue().get(\"key\"));结果：***************hello redis setIfAbsent Boolean setIfAbsent(K key, V value); 1234使用: System.out.println(template.opsForValue().setIfAbsent(\"multi1\",\"multi1\"));// false multi1之前已经存在 System.out.println(template.opsForValue().setIfAbsent(\"multi111\",\"multi111\")); //true multi111之前不存在结果：false true multiSet void multiSet(Map&lt;? extends K, ? extends V&gt; m); 为多个键分别设置它们的值 1234567891011使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;(); maps.put(\"multi1\",\"multi1\"); maps.put(\"multi2\",\"multi2\"); maps.put(\"multi3\",\"multi3\"); template.opsForValue().multiSet(maps); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); keys.add(\"multi1\"); keys.add(\"multi2\"); keys.add(\"multi3\"); System.out.println(template.opsForValue().multiGet(keys)); 结果：[multi1, multi2, multi3] multiSetIfAbsent Boolean multiSetIfAbsent(Map&lt;? extends K, ? extends V&gt; m); 为多个键分别设置它们的值，如果存在则返回false，不存在返回true 123456789101112使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;(); maps.put(\"multi11\",\"multi11\"); maps.put(\"multi22\",\"multi22\"); maps.put(\"multi33\",\"multi33\"); Map&lt;String,String&gt; maps2 = new HashMap&lt;String, String&gt;(); maps2.put(\"multi1\",\"multi1\"); maps2.put(\"multi2\",\"multi2\"); maps2.put(\"multi3\",\"multi3\"); System.out.println(template.opsForValue().multiSetIfAbsent(maps)); System.out.println(template.opsForValue().multiSetIfAbsent(maps2));结果：true false get V get(Object key); 123使用：template.opsForValue().set(\"key\",\"hello world\"); System.out.println(\"***************\"+template.opsForValue().get(\"key\"));结果：***************hello world getAndSet V getAndSet(K key, V value); 设置键的字符串值并返回其旧值 123使用：template.opsForValue().set(\"getSetTest\",\"test\"); System.out.println(template.opsForValue().getAndSet(\"getSetTest\",\"test2\"));结果：test multiGet List multiGet(Collection keys); 为多个键分别取出它们的值 1234567891011使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;(); maps.put(\"multi1\",\"multi1\"); maps.put(\"multi2\",\"multi2\"); maps.put(\"multi3\",\"multi3\"); template.opsForValue().multiSet(maps); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); keys.add(\"multi1\"); keys.add(\"multi2\"); keys.add(\"multi3\"); System.out.println(template.opsForValue().multiGet(keys));结果：[multi1, multi2, multi3] increment Long increment(K key, long delta); 支持整数 123使用：template.opsForValue().increment(\"increlong\",1); System.out.println(\"***************\"+template.opsForValue().get(\"increlong\"));结果：***************1 increment Double increment(K key, double delta); 支持浮点数 123使用：template.opsForValue().increment(\"increlong\",1.2); System.out.println(\"***************\"+template.opsForValue().get(\"increlong\"));结果：***************2.2 append Integer append(K key, String value); 如果key已经存在并且是一个字符串，则该命令将该值追加到字符串的末尾。如果键不存在，则它被创建并设置为空字符串，因此APPEND在这种特殊情况下将类似于SET。 123456使用：template.opsForValue().append(\"appendTest\",\"Hello\"); System.out.println(template.opsForValue().get(\"appendTest\")); template.opsForValue().append(\"appendTest\",\"world\"); System.out.println(template.opsForValue().get(\"appendTest\"));结果：Hello Helloworld get String get(K key, long start, long end); 截取key所对应的value字符串 123456789使用：appendTest对应的value为Helloworld System.out.println(\"*********\"+template.opsForValue().get(\"appendTest\",0,5));结果：*********Hellow使用：System.out.println(\"*********\"+template.opsForValue().get(\"appendTest\",0,-1));结果：*********Helloworld使用： System.out.println(\"*********\"+template.opsForValue().get(\"appendTest\",-3,-1));结果：*********rld size Long size(K key); 返回key所对应的value值得长度 123使用：template.opsForValue().set(\"key\",\"hello world\"); System.out.println(\"***************\"+template.opsForValue().size(\"key\"));结果：***************11 setBit Boolean setBit(K key, long offset, boolean value); 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value 123456789使用：template.opsForValue().set(\"bitTest\",\"a\"); // 'a' 的ASCII码是 97。转换为二进制是：01100001 // 'b' 的ASCII码是 98 转换为二进制是：01100010 // 'c' 的ASCII码是 99 转换为二进制是：01100011 //因为二进制只有0和1，在setbit中true为1，false为0，因此我 要变为'b'的话第六位设置为1，第七位设置为0 template.opsForValue().setBit(\"bitTest\",6, true); template.opsForValue().setBit(\"bitTest\",7, false); System.out.println(template.opsForValue().get(\"bitTest\")); 结果：b getBit Boolean getBit(K key, long offset); 获取键对应值的ascii码的在offset处位值 12使用：System.out.println(template.opsForValue().getBit(\"bitTest\",7));结果：false Redis的List数据结构这边我们把RedisTemplate序列化方式改回之前的 12345678910Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setKeySerializer(jackson2JsonRedisSerializer); template.setValueSerializer(jackson2JsonRedisSerializer); template.setHashKeySerializer(jackson2JsonRedisSerializer); template.setHashValueSerializer(jackson2JsonRedisSerializer); Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边） ListOperations专门操作list列表: List range(K key, long start, long end); 返回存储在键中的列表的指定元素。偏移开始和停止是基于零的索引，其中0是列表的第一个元素（列表的头部），1是下一个元素 12使用：System.out.println(template.opsForList().range(\"list\",0,-1));结果:[c#, c++, python, java, c#, c#] void trim(K key, long start, long end); 修剪现有列表，使其只包含指定的指定范围的元素，起始和停止都是基于0的索引 12345使用：System.out.println(template.opsForList().range(\"list\",0,-1)); template.opsForList().trim(\"list\",1,-1);//裁剪第一个元素 System.out.println(template.opsForList().range(\"list\",0,-1));结果: [c#, c++, python, java, c#, c#] [c++, python, java, c#, c#] Long size(K key); 返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。 12使用：System.out.println(template.opsForList().size(\"list\"));结果:6 Long leftPush(K key, V value); 将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从左边插入） 1234567使用：template.opsForList().leftPush(\"list\",\"java\"); template.opsForList().leftPush(\"list\",\"python\"); template.opsForList().leftPush(\"list\",\"c++\");结果: 返回的结果为推送操作后的列表的长度123 Long leftPushAll(K key, V… values); 批量把一个数组插入到列表中 1234使用：String[] stringarrays = new String[]&#123;\"1\",\"2\",\"3\"&#125;; template.opsForList().leftPushAll(\"listarray\",stringarrays); System.out.println(template.opsForList().range(\"listarray\",0,-1));结果: [3, 2, 1] Long leftPushAll(K key, Collection values); 批量把一个集合插入到列表中 1234567使用：List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;(); strings.add(\"1\"); strings.add(\"2\"); strings.add(\"3\"); template.opsForList().leftPushAll(\"listcollection4\", strings); System.out.println(template.opsForList().range(\"listcollection4\",0,-1));结果: [3, 2, 1] Long leftPushIfPresent(K key, V value); 只有存在key对应的列表才能将这个value值插入到key所对应的列表中 1234567891011 使用： System.out.println(template.opsForList().leftPushIfPresent(\"leftPushIfPresent\",\"aa\")); System.out.println(template.opsForList().leftPushIfPresent(\"leftPushIfPresent\",\"bb\"));==========分割线===========truetrue System.out.println(template.opsForList().leftPush(\"leftPushIfPresent\",\"aa\")); System.out.println(template.opsForList().leftPushIfPresent(\"leftPushIfPresent\",\"bb\"));结果: 0 0 ==========分割线=========== 1 2 Long leftPush(K key, V pivot, V value); 把value值放到key对应列表中pivot值的左面，如果pivot值存在的话 123使用：template.opsForList().leftPush(\"list\",\"java\",\"oc\"); System.out.print(template.opsForList().range(\"list\",0,-1));结果：[c++, python, oc, java, c#, c#] Long rightPush(K key, V value); 将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入） 1234567使用：template.opsForList().rightPush(\"listRight\",\"java\"); template.opsForList().rightPush(\"listRight\",\"python\"); template.opsForList().rightPush(\"listRight\",\"c++\");结果:123 Long rightPushAll(K key, V… values); 1234使用：String[] stringarrays = new String[]&#123;\"1\",\"2\",\"3\"&#125;; template.opsForList().rightPushAll(\"listarrayright\",stringarrays); System.out.println(template.opsForList().range(\"listarrayright\",0,-1));结果: [1, 2, 3] Long rightPushAll(K key, Collection values); 1234567使用：List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;(); strings.add(\"1\"); strings.add(\"2\"); strings.add(\"3\"); template.opsForList().rightPushAll(\"listcollectionright\", strings); System.out.println(template.opsForList().range(\"listcollectionright\",0,-1));结果: [1, 2, 3] Long rightPushIfPresent(K key, V value); 只有存在key对应的列表才能将这个value值插入到key所对应的列表中 1234567891011使用： System.out.println(template.opsForList().rightPushIfPresent(\"rightPushIfPresent\",\"aa\")); System.out.println(template.opsForList().rightPushIfPresent(\"rightPushIfPresent\",\"bb\")); System.out.println(\"==========分割线===========\"); System.out.println(template.opsForList().rightPush(\"rightPushIfPresent\",\"aa\")); System.out.println(template.opsForList().rightPushIfPresent(\"rightPushIfPresent\",\"bb\"));结果: 00==========分割线===========12 Long rightPush(K key, V pivot, V value); 把value值放到key对应列表中pivot值的右面，如果pivot值存在的话 12345使用：System.out.println(template.opsForList().range(\"listRight\",0,-1)); template.opsForList().rightPush(\"listRight\",\"python\",\"oc\"); System.out.println(template.opsForList().range(\"listRight\",0,-1));结果: [java, python, c++][java, python, oc, c++] void set(K key, long index, V value); 在列表中index的位置设置value值 12345使用：System.out.println(template.opsForList().range(\"listRight\",0,-1)); template.opsForList().set(\"listRight\",1,\"setValue\"); System.out.println(template.opsForList().range(\"listRight\",0,-1));结果:[java, python, oc, c++] [java, setValue, oc, c++] Long remove(K key, long count, Object value); 从存储在键中的列表中删除等于值的元素的第一个计数事件。计数参数以下列方式影响操作： count&gt; 0：删除等于从头到尾移动的值的元素。 count &lt;0：删除等于从尾到头移动的值的元素。 count = 0：删除等于value的所有元素。 12345使用：System.out.println(template.opsForList().range(\"listRight\",0,-1)); template.opsForList().remove(\"listRight\",1,\"setValue\");//将删除列表中存储的列表中第一次次出现的“setValue”。 System.out.println(template.opsForList().range(\"listRight\",0,-1));结果: [java, setValue, oc, c++] [java, oc, c++] V index(K key, long index); 根据下表获取列表中的值，下标是从0开始的 1234使用：System.out.println(template.opsForList().range(\"listRight\",0,-1)); System.out.println(template.opsForList().index(\"listRight\",2));结果: [java, oc, c++] c++ V leftPop(K key); 弹出最左边的元素，弹出之后该值在列表中将不复存在 1234567使用：System.out.println(template.opsForList().range(\"list\",0,-1)); System.out.println(template.opsForList().leftPop(\"list\")); System.out.println(template.opsForList().range(\"list\",0,-1));结果: [c++, python, oc, java, c#, c#]c++[python, oc, java, c#, c#] V leftPop(K key, long timeout, TimeUnit unit); 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 1使用：用法与 leftPop(K key);一样 V rightPop(K key); 弹出最右边的元素，弹出之后该值在列表中将不复存在 123456使用： System.out.println(template.opsForList().range(\"list\",0,-1)); System.out.println(template.opsForList().rightPop(\"list\")); System.out.println(template.opsForList().range(\"list\",0,-1));结果: [python, oc, java, c#, c#] c# [python, oc, java, c#] V rightPop(K key, long timeout, TimeUnit unit) 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 1使用：用法与 rightPop(K key);一样 V rightPopAndLeftPush(K sourceKey, K destinationKey); 用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。 123456使用： System.out.println(template.opsForList().range(\"list\",0,-1)); template.opsForList().rightPopAndLeftPush(\"list\",\"rightPopAndLeftPush\"); System.out.println(template.opsForList().range(\"list\",0,-1)); System.out.println(template.opsForList().range(\"rightPopAndLeftPush\",0,-1));结果: [oc, java,c#] [oc, java] [c#] V rightPopAndLeftPush(K sourceKey, K destinationKey, long timeout, TimeUnit unit); 用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 1使用：用法与rightPopAndLeftPush(K sourceKey, K destinationKey)一样 Redis的Hash数据机构 Redis的散列可以让用户将多个键值对存储到一个Redis键里面。 public interface HashOperations HashOperations提供一系列方法操作hash： 123456789初始数据://template.opsForHash().put(\"redisHash\",\"name\",\"tom\");//template.opsForHash().put(\"redisHash\",\"age\",26);//template.opsForHash().put(\"redisHash\",\"class\",\"6\");//Map&lt;String,Object&gt; testMap = new HashMap(); //testMap.put(\"name\",\"jack\"); //testMap.put(\"age\",27); //testMap.put(\"class\",\"1\"); //template.opsForHash().putAll(\"redisHash1\",testMap); Long delete(H key, Object… hashKeys); 删除给定的哈希hashKeys 1234使用：System.out.println(template.opsForHash().delete(\"redisHash\",\"name\")); System.out.println(template.opsForHash().entries(\"redisHash\"));结果: 1&#123;class=6, age=28.1&#125; Boolean hasKey(H key, Object hashKey); 确定哈希hashKey是否存在 1234使用：System.out.println(template.opsForHash().hasKey(\"redisHash\",\"age\")); System.out.println(template.opsForHash().hasKey(\"redisHash\",\"ttt\"));结果：true false HV get(H key, Object hashKey); 从键中的哈希获取给定hashKey的值 12使用：System.out.println(template.opsForHash().get(\"redisHash\",\"age\"));结果：26 List multiGet(H key, Collection hashKeys); 从哈希中获取给定hashKey的值 12345使用：List&lt;Object&gt; kes = new ArrayList&lt;Object&gt;(); kes.add(\"name\"); kes.add(\"age\"); System.out.println(template.opsForHash().multiGet(\"redisHash\",kes));结果：[jack, 28.1] Long increment(H key, HK hashKey, long delta); 通过给定的delta增加散列hashKey的值（整型） 1234使用：System.out.println(template.opsForHash().get(\"redisHash\",\"age\")); System.out.println(template.opsForHash().increment(\"redisHash\",\"age\",1));结果：26 27 Double increment(H key, HK hashKey, double delta); 通过给定的delta增加散列hashKey的值（浮点数） 1234使用：System.out.println(template.opsForHash().get(\"redisHash\",\"age\")); System.out.println(template.opsForHash().increment(\"redisHash\",\"age\",1.1));结果：27 28.1 Set keys(H key); 获取key所对应的散列表的key 123使用：System.out.println(template.opsForHash().keys(\"redisHash1\")); //redisHash1所对应的散列表为&#123;class=1, name=jack, age=27&#125;结果：[name, class, age] Long size(H key); 获取key所对应的散列表的大小个数 123使用：System.out.println(template.opsForHash().size(\"redisHash1\")); //redisHash1所对应的散列表为&#123;class=1, name=jack, age=27&#125;结果：3 void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m); 使用m中提供的多个散列字段设置到key对应的散列表中 1234567使用：Map&lt;String,Object&gt; testMap = new HashMap(); testMap.put(\"name\",\"jack\"); testMap.put(\"age\",27); testMap.put(\"class\",\"1\"); template.opsForHash().putAll(\"redisHash1\",testMap); System.out.println(template.opsForHash().entries(\"redisHash1\"));结果：&#123;class=1, name=jack, age=27&#125; void put(H key, HK hashKey, HV value); 设置散列hashKey的值 12345使用：template.opsForHash().put(\"redisHash\",\"name\",\"tom\"); template.opsForHash().put(\"redisHash\",\"age\",26); template.opsForHash().put(\"redisHash\",\"class\",\"6\"); System.out.println(template.opsForHash().entries(\"redisHash\"));结果：&#123;age=26, class=6, name=tom&#125; Boolean putIfAbsent(H key, HK hashKey, HV value); 仅当hashKey不存在时才设置散列hashKey的值 1234使用：System.out.println(template.opsForHash().putIfAbsent(\"redisHash\",\"age\",30));truetrueSystem.out.println(template.opsForHash().putIfAbsent(\"redisHash\",\"kkk\",\"kkk\"));结果：false true List values(H key); 获取整个哈希存储的值根据密钥 12使用：System.out.println(template.opsForHash().values(\"redisHash\"));结果：[tom, 26, 6] Map entries(H key); 获取整个哈希存储根据密钥 12使用：System.out.println(template.opsForHash().entries(\"redisHash\"));结果：&#123;age=26, class=6, name=tom&#125; Cursor","categories":[{"name":"Redis","slug":"Redis","permalink":"http://litxiaosa.me/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://litxiaosa.me/tags/Redis/"}]},{"title":"SpringBoot（十）之 RabbitMQ","slug":"SpringBoot（十）之 RabbitMQ","date":"2017-12-14T08:27:18.000Z","updated":"2017-12-28T09:46:58.451Z","comments":true,"path":"2017/12/14/SpringBoot（十）之 RabbitMQ/","link":"","permalink":"http://litxiaosa.me/2017/12/14/SpringBoot（十）之 RabbitMQ/","excerpt":"本文要介绍的RabbitMQ是以AMQP协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。 安装在RabbitMQ官网的下载页面 https://www.rabbitmq.com/download.html中，我们可以获取到针对各种不同操作系统的安装包和说明文档。 由于我用的是MAC ，这里介绍怎么在MAC上安装RabbitMQ。","text":"本文要介绍的RabbitMQ是以AMQP协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。 安装在RabbitMQ官网的下载页面 https://www.rabbitmq.com/download.html中，我们可以获取到针对各种不同操作系统的安装包和说明文档。 由于我用的是MAC ，这里介绍怎么在MAC上安装RabbitMQ。 在Mac OS X中使用brew工具，可以很容易的安装RabbitMQ的服务端，只需要按如下命令操作即可： brew更新到最新版本，执行：brew update 安装Erlang，执行：brew install erlang 安装RabbitMQ Server，执行：brew install rabbitmq 我们这里说一下brew工具，这是他的 官网 , 它是macOS 缺失的软件包管理器，非常好用，官网有中文，不知道的可以自己研究一下，如果你的电脑没有安装brew, 官网有安装教程，这里也不再赘述。 BabbitMQ是基于Erlang，安装Erlang时为了避免未知报错。 通过上面的命令，RabbitMQ Server的命令会被安装到 /usr/local/sbin，并不会自动加到用户的环境变量中去，所以我们需要在.bash_profile文件中增加下面内容： 1PATH=$PATH:/usr/local/sbin 打开 .bash_profile 1open .bash_profile 输入下面的命令使修改生效 1source .bash_profile 这样，我们就可以通过 rabbitmq-server 命令来启动RabbitMQ的服务端了。 下图表示启动成功 RabbitMQ管理我们可以直接通过配置文件的访问进行管理，也可以通过Web的访问进行管理。下面我们将介绍如何通过Web进行管理。 执行 rabbitmq-plugins enable rabbitmq_management 命令，开启Web管理插件，这样我们就可以通过浏览器来进行管理了。 打开浏览器并访问：http://localhost:15672/， 并使用默认用户guest登录，密码也为guest。我们可以看到如下图的管理页面： 点击 Admin 标签，在这里可以进行用户的管理。 与Spring Boot整合下面，我们通过在Spring Boot应用中整合RabbitMQ，并实现一个简单的发送、接收消息的例子来对RabbitMQ有一个直观的感受和理解。 在Spring Boot中整合RabbitMQ是一件非常容易的事，下面我们就来详细说说整合过程： 这次我们新建一个Spring Boot工程，命名为：“rabbitmq” 在pom.xml中引入如下依赖内容，其中spring-boot-starter-amqp用于支持RabbitMQ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在 application.properties 中配置关于RabbitMQ的连接和用户信息，用户可以回到上面的安装内容，在管理页面中创建用户,这里我们用默认的账号 123456spring.application.name=rabbitmqspring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest 创建消息生产者 Sender。通过注入 AmqpTemplate 接口的实例来实现消息的发送，AmqpTemplate 接口定义了一套针对AMQP协议的基础操作。在Spring Boot中会根据配置来注入其具体实现。在该生产者，我们会产生一个字符串，并发送到名为hello的队列中 123456789101112public class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send()&#123; String context = \"RabbitMQ\" + new Date(); System.out.println(\"Sender : \" + context); this.rabbitTemplate.convertAndSend(\"hello\", context); &#125;&#125; 创建消息消费者 Receiver。通过 @RabbitListener 注解定义该类对hello队列的监听，并用 @RabbitHandler 注解来指定对消息的处理方法。所以，该消费者实现了对hello队列的消费，消费操作为输出消息的字符串内容。 12345678@RabbitListener(queues = \"hello\")public class Receiver &#123; @RabbitHandler public void process(String hello)&#123; System.out.println(\"Receiver : \"+hello); &#125;&#125; 创建RabbitMQ的配置类 RabbitConfig，用来配置队列、交换器、路由等高级信息。这里我们以入门为主，先以最小化的配置来定义，以完成一个基本的生产和消费过程。 123456789101112import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RabbitConfig &#123; @Bean public Queue helloQueue() &#123; return new Queue(\"hello\"); &#125;&#125; 创建单元测试类，用来调用消息生产： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class RabbitmqApplicationTests &#123; @Autowired private Sender sender; public void test()&#123; sender.send(); &#125;&#125; 完成程序编写之后，下面开始尝试运行。首先确保RabbitMQ Server已经开始，然后进行下面的操作： 启动应用主类，从控制台中，我们看到如下内容，程序创建了一个访问127.0.0.1:5672 中 springcloud 的连接。 1Created new connection: rabbitConnectionFactory#52100cb8:0/SimpleConnection@184db0f4 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 62685] 同时，我们通过RabbitMQ的控制面板，可以看到Connection和Channels中包含当前连接的条目。 运行单元测试类，我们可以看到控制台中输出下面的内容，消息被发送到了RabbitMQ Server的hello队列中。 1Sender : RabbitMQ----------------------Thu Dec 14 18:44:16 CST 2017 切换到应用主类的控制台，我们可以看到类似如下输出，消费者对hello队列的监听程序执行了，并输出了接受到的消息信息 1Receiver : RabbitMQ----------------------Thu Dec 14 18:44:16 CST 2017 通过上面的示例，我们在Spring Boot应用中引入spring-boot-starter-amqp模块，进行简单配置就完成了对RabbitMQ的消息生产和消费的开发内容。然而在实际应用中，我们还有很多内容没有演示，这里不做更多的讲解，读者可以自行查阅RabbitMQ的官方教程，有更全面的了解。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（九）之 事务管理","slug":"SpringBoot（九）之 事务管理","date":"2017-12-14T05:27:18.000Z","updated":"2017-12-28T09:47:22.305Z","comments":true,"path":"2017/12/14/SpringBoot（九）之 事务管理/","link":"","permalink":"http://litxiaosa.me/2017/12/14/SpringBoot（九）之 事务管理/","excerpt":"什么是事务？我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。","text":"什么是事务？我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。 事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务 快速入门在Spring Boot中，当我们使用了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或 JpaTransactionManager。所以我们不需要任何额外配置就可以用 @Transactional 注解进行事务的使用。 我们用之前的项目作为基础模版，我们引入了spring-data-jpa，并创建了User实体以及对User的数据访问对象UserRepository，在ApplicationTest类中实现了使用UserRepository进行数据读写的单元测试用例，如下： 1234567891011121314151617181920@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class DemoApplicationTests &#123;true@AutowiredtrueUserRepository userRepository;true@Testtruepublic void test ()&#123;truetrue//创建5条数据truetrueuserRepository.save(new User(\"a\",\"110\"));truetrueuserRepository.save(new User(\"b\",\"112\"));truetrueuserRepository.save(new User(\"c\",\"114\"));truetrueuserRepository.save(new User(\"d\",\"115\"));truetrueuserRepository.save(new User(\"e\",\"119\"));true&#125;&#125; 可以看到，在这个单元测试用例中，使用UserRepository对象连续创建了5个User实体到数据库中，下面我们人为的来制造一些异常，看看会发生什么情况。 通过定义User的userName属性长度为5，这样通过创建时User实体的userName属性超长就可以触发异常产生。 123456789101112131415161718192021222324@Data@Entitypublic class User &#123; @Id @GeneratedValue private Long id; @Column(nullable = false, length = 5) private String userName; @Column(nullable = false) private String passWord; public User()&#123; &#125; public User(String userName, String passWord) &#123; this.userName = userName; this.passWord = passWord; &#125;&#125; 修改测试用例中创建记录的语句，将一条记录的userName长度超过5，如下：userName为AAAAAAAAAAAAAA的User对象将会抛出异常。 12345678910@Testpublic void test ()&#123;true//创建5条数据trueuserRepository.save(new User(\"a\",\"110\"));trueuserRepository.save(new User(\"b\",\"112\"));trueuserRepository.save(new User(\"c\",\"114\"));trueuserRepository.save(new User(\"AAAAAAAAAAAAAA\",\"115\"));trueuserRepository.save(new User(\"e\",\"119\"));&#125; 执行测试用例，可以看到控制台中抛出了如下异常，userName字段超长： 123456Caused by: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column 'user_name' at row 1trueat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3971)trueat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3909)trueat com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2527)trueat com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2680)trueat com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2487) 此时查数据库中，创建了userName从a到c的记录，没有AAAAAAAAAAAAAA,e的记录。而若这是一个希望保证完整性操作的情况下，a到c的记录希望能在发生异常的时候被回退，这时候就可以使用事务让它实现回退，做法非常简单，我们只需要在test函数上添加@Transactional注解即可。 12345678910@Test@Transactionalpublic void test ()&#123; //创建5条数据 userRepository.save(new User(\"a\",\"110\")); userRepository.save(new User(\"b\",\"112\")); userRepository.save(new User(\"c\",\"114\")); userRepository.save(new User(\"AAAAAAAAAAAAAA\",\"115\")); userRepository.save(new User(\"e\",\"119\"));&#125; 我们把刚刚插入的数据删掉，从新执行测试用例。再看数据库中，User表就没有a到c的用户数据了，成功实现了自动回滚。 这里主要通过单元测试演示了如何使用@Transactional注解来声明一个函数需要被事务管理，通常我们单元测试为了保证每个测试之间的数据独立，会使用@Rollback注解让每个单元测试都能在结束时回滚。而真正在开发业务逻辑时，我们通常在service层接口中使用@Transactional来对各个业务逻辑进行事务管理的配置。 事务详解上面的例子中我们使用了默认的事务配置，可以满足一些基本的事务需求，但是当我们项目较大较复杂时（比如，有多个数据源等），这时候需要在声明事务时，指定不同的事务管理器。在声明事务时，只需要通过value属性指定配置的事务管理器名即可，例如： @Transactional(value=&quot;transactionManagerPrimary&quot;)。 除了指定不同的事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释： 隔离级别我们可以org.springframework.transaction.annotation.Isolation枚举类中定义了五个表示隔离级别的值： 1234567public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);&#125; DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。 READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读 SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 指定方法：通过使用isolation属性设置，例如： 1@Transactional(isolation = Isolation.READ_COMMITTED) 传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 我们可以看org.springframework.transaction.annotation.Propagation枚举类中定义了7个表示传播行为的枚举值： 123456789public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6);&#125; REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。 指定方法：通过使用propagation属性设置，例如： 1@Transactional(propagation = Propagation.REQUIRED)","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（八）之 整合 MyBatis","slug":"SpringBoot（八）之 整合 MyBatis","date":"2017-12-13T08:27:18.000Z","updated":"2017-12-13T10:09:22.039Z","comments":true,"path":"2017/12/13/SpringBoot（八）之 整合 MyBatis/","link":"","permalink":"http://litxiaosa.me/2017/12/13/SpringBoot（八）之 整合 MyBatis/","excerpt":"现在大部分的项目还是整合的mybatis，下边我们就学习SpringBoot整合MyBatis。使用的项目基础是我们之前的教程中一步一步建立起来的。 pom.xml 中引入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖","text":"现在大部分的项目还是整合的mybatis，下边我们就学习SpringBoot整合MyBatis。使用的项目基础是我们之前的教程中一步一步建立起来的。 pom.xml 中引入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖 同之前介绍的使用spring-data连接数据库一样，在application.properties中配置mysql的连接配置 1234spring.datasource.url=jdbc:mysql://localhost:3306/demospring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver 在Mysql中创建product表，包含id(bigint)、name(varcher)、colour(varcher)字段。同时，创建映射对象Product 123456789@Data //此注解为lombokpublic class Product &#123; private Long id; private String name; private String colour;&#125; 创建Product映射的操作ProductMapper，为了后续单元测试验证，实现插入和查询操作 12345678910111213@Mapperpublic interface ProductMapper &#123;@Insert(\"insert into product(name, colour) values(#&#123;name&#125;, #&#123;colour&#125;)\")int insert(@Param(\"name\") String name, @Param(\"colour\") String colour);@Select(\"select * from product where name = #&#123;name&#125;\")Product getProductByName(@Param(\"name\") String name);@Update(\"update product set colour = #&#123;colour&#125; where name =#&#123;name&#125;\")int updateColourByName(@Param(\"name\") String name , @Param(\"colour\") String colour);&#125; 接下来，我们分别来介绍下这个注解方式。 Mybatis注解的方式很简单，只要定义一个dao接口，然后sql语句通过注解写在接口方法上。最后给这个接口添加@Mapper注解就行了。如上图。 简单的语句只需要使用@Insert、@Update、@Delete、@Select这4个注解即可。 创建测试 123456789101112131415161718192021222324 @SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class DemoApplicationTests &#123; @Autowired private ProductMapper productMapper; @Test public void insert()&#123; productMapper.insert(\"红桃A\", \"red\"); &#125; @Test public void getProductByName()&#123; Product p = productMapper.getProductByName(\"红桃A\"); &#125; @Test public void update()&#123; productMapper.updateColourByName(\"红桃A\", \"blue\"); &#125;&#125; 分页插件 pom.xml中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 然后你只需在查询list之前使用PageHelper.startPage(int pageNum, int pageSize)方法即可。pageNum是第几页，pageSize是每页多少条。 分页插件PageHelper项目地址： https://github.com/pagehelper/Mybatis-PageHelper","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（七）之 Spring-data-jpa","slug":"SpringBoot（七）之 Spring-data-jpa","date":"2017-12-06T01:27:18.000Z","updated":"2017-12-06T06:57:45.225Z","comments":true,"path":"2017/12/06/SpringBoot（七）之 Spring-data-jpa/","link":"","permalink":"http://litxiaosa.me/2017/12/06/SpringBoot（七）之 Spring-data-jpa/","excerpt":"Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。提供了包括增删改查等在内的常用功能，且易于扩展。学习并使用 Spring Data JPA 可以极大提高开发效率,他的出现主要是为了简化现有的持久化开发工作和整合ORM技术,值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点 。","text":"Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。提供了包括增删改查等在内的常用功能，且易于扩展。学习并使用 Spring Data JPA 可以极大提高开发效率,他的出现主要是为了简化现有的持久化开发工作和整合ORM技术,值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点 。 工程配置在pom.xml中添加相关依赖，加入以下内容 12345678910111213141516&lt;dependency &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 在application.properties中配置：数据库连接信息（自动创建表结构的设置，例如使用mysql的情况如下： 123456spring.datasource.url=jdbc:mysql://localhost:3306/demospring.datasource.username=root spring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=create-drop spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 创建实体创建一个User实体，包含id（主键）、userName（姓名）、passWord（密码）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 123456789101112131415161718192021@Data@Entitypublic class User &#123; @Id @GeneratedValue private Long id; @Column(nullable = false) private String userName; @Column(nullable = false) private String passWord; public User()&#123;&#125; public User(String userName, String passWord) &#123; this.userName = userName; this.passWord = passWord; &#125;&#125; 创建数据访问接口下面针对User实体创建对应的Repository接口实现对该实体的数据访问，如下代码： 12345678910public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; User findByUserName(String userName); User findByUserNameAndPassWord(String userName, String passWord); @Query(\"from User u where u.userName=:userName\") User findUser(@Param(\"userName\") String userName);&#125; 在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类 下面对上面的UserRepository做一些解释，该接口继承自JpaRepository，通过查看JpaRepository接口的API文档，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。 在上例中，我们可以看到下面两个函数： User findByUserName(String userName) User findByUserNameAndPassWord(String userName, String passWord) 它们分别实现了按userName查询User实体和按userName和passWord查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：通过解析方法名创建查询。 除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。 单元测试在完成了上面的数据访问接口之后,我们编写对应的单元测试来验证编写的内容是否正确,我们在测试类中编写如下代码 12345678910111213141516171819202122232425262728293031323334353637383940@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class DemoApplicationTests &#123; @Autowired private UserRepository userRepository; @Test public void testJpa()&#123; //创建5条数据 userRepository.save(new User(\"a\",\"110\")); userRepository.save(new User(\"b\",\"112\")); userRepository.save(new User(\"c\",\"114\")); userRepository.save(new User(\"d\",\"115\")); userRepository.save(new User(\"e\",\"119\")); // 测试findAll, 查询所有记录 int count = userRepository.findAll().size(); System.out.println(count); //测试findByUserName, 查询姓名为a的User User user = userRepository.findByUserName(\"a\"); System.out.println(user); // 测试findByUserNameAndPassWord, 查询姓名为e密码为119的User user = userRepository.findByUserNameAndPassWord(\"e\", \"119\"); System.out.println(user); // 测试findUser, 查询姓名为b的User user = userRepository.findUser(\"b\"); System.out.println(user); // 测试删除姓名为c的User userRepository.delete(userRepository.findByUserName(\"c\")); //测试findAll, 查询所有记录, 验证上面的删除是否成功 count = userRepository.findAll().size(); System.out.println(count); &#125;&#125;","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（六）之 使用Swagger2构建RESTful API","slug":"SpringBoot（六）之 使用Swagger2构建RESTful API","date":"2017-12-05T08:27:18.000Z","updated":"2017-12-05T08:12:43.252Z","comments":true,"path":"2017/12/05/SpringBoot（六）之 使用Swagger2构建RESTful API/","link":"","permalink":"http://litxiaosa.me/2017/12/05/SpringBoot（六）之 使用Swagger2构建RESTful API/","excerpt":"由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。 传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂，高质量地创建这份文档本身就是件非常吃力的事。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。","text":"由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。 传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂，高质量地创建这份文档本身就是件非常吃力的事。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 为了解决上面这样的问题，本文将介绍RESTful API的好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API 下面来具体介绍，如果在Spring Boot中使用Swagger2 添加Swagger2依赖在pom.xml中加入Swagger2的依赖 1234567891011&lt;dependency&gt;true&lt;groupId&gt;io.springfox&lt;/groupId&gt;true&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;true&lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;true&lt;groupId&gt;io.springfox&lt;/groupId&gt;true&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;true&lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类在DemoApplication.java同级创建Swagger2的配置类Swagger 12345678910111213141516171819202122232425@Configuration@EnableSwagger2public class Swagger &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.xiaosa.demo\")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"Spring Boot中使用Swagger2构建RESTful API\") .description(\"更多Spring Boot相关文章请关注：http://litxiaosa.me\") .termsOfServiceUrl(\"http://litxiaosa.me/\") .contact(\"潇洒\") .version(\"1.0\") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明 12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(value=\"/users\") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value=\"获取用户列表\", notes=\"\") @PostMapping(value = \"getUserList\") public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; user = new ArrayList&lt;User&gt;(users.values()); return user; &#125; @ApiOperation(value=\"创建用户\", notes=\"根据User对象创建用户\") @ApiImplicitParam(name = \"user\", value = \"用户详细实体user\", required = true, dataType = \"User\") @PostMapping(value = \"createUser\") public String createUser(@RequestBody User user) &#123; users.put(user.getId(), user); return \"success\"; &#125; @ApiOperation(value=\"获取用户详细信息\", notes=\"根据url的id来获取用户详细信息\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @PostMapping(value = \"getUser\") public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value=\"删除用户\", notes=\"根据user的id来指定删除对象\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @DeleteMapping(value = \"deleteUser\") public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return \"success\"; &#125;&#125; 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html 就能看到前文所展示的RESTful API的页面。 我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。 API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！ 相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（五）之 统一异常处理","slug":"SpringBoot（五）之 统一异常处理","date":"2017-12-05T06:27:18.000Z","updated":"2017-12-05T07:29:55.473Z","comments":true,"path":"2017/12/05/SpringBoot（五）之 统一异常处理/","link":"","permalink":"http://litxiaosa.me/2017/12/05/SpringBoot（五）之 统一异常处理/","excerpt":"我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 我们写一个一段代码： 1234567891011/** * @author xiaosa */@Controllerpublic class ErrorController &#123; @RequestMapping(\"hello\") public String error() throws Exception &#123; throw new Exception(\"发生错误！！\"); &#125;&#125;","text":"我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 我们写一个一段代码： 1234567891011/** * @author xiaosa */@Controllerpublic class ErrorController &#123; @RequestMapping(\"hello\") public String error() throws Exception &#123; throw new Exception(\"发生错误！！\"); &#125;&#125; 此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。 虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。 创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 1234567891011121314@ControllerAdvicepublic class GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = \"error\"; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject(\"exception\", e); mav.addObject(\"url\", req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125;&#125; 实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Error Handler&lt;/h1&gt; &lt;div th:text=\"$&#123;url&#125;\"&gt;&lt;/div&gt; &lt;div th:text=\"$&#123;exception.message&#125;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动该应用，访问：http://localhost:8080/hello，可以看到如下错误提示页面: 通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（四）之 静态资源和拦截器","slug":"SpringBoot（四）之 静态资源和拦截器","date":"2017-12-05T02:27:18.000Z","updated":"2017-12-05T06:42:23.274Z","comments":true,"path":"2017/12/05/SpringBoot（四）之 静态资源和拦截器/","link":"","permalink":"http://litxiaosa.me/2017/12/05/SpringBoot（四）之 静态资源和拦截器/","excerpt":"本章我们来介绍下SpringBoot对静态资源的支持以及很重要的一个类WebMvcConfigurerAdapter 通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter，重写这个类中的方法可以让我们增加额外的配置","text":"本章我们来介绍下SpringBoot对静态资源的支持以及很重要的一个类WebMvcConfigurerAdapter 通常情况下，Spring Boot的自动配置是符合我们大多数需求的。在你既需要保留Spring Boot提供的便利，有需要增加自己的额外的配置的时候，可以定义一个配置类并继承WebMvcConfigurerAdapter，重写这个类中的方法可以让我们增加额外的配置 自定义资源映射addResourceHandlers比如，我们想自定义静态资源映射目录的话，只需重写addResourceHandlers方法即可。 1234567891011121314151617/** * @author xiaosa */@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter&#123; /** * 配置静态访问资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"image/**\").addResourceLocations(\"classpath:/image/\"); super.addResourceHandlers(registry); &#125;&#125; 通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。我们访问自定义image文件夹中的a.jpg 图片的地址为 http://localhost:8080/image/a.jpg addResourceLocations指的是文件放置的目录，addResoureHandler指的是对外暴露的访问路径 页面跳转addViewControllersSpringBoot 中，重写WebMvcConfigurerAdapter中的addViewControllers方法即可达到效果 123456789/** * 页面跳转 * @param registry */@Overridepublic void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"login\").setViewName(\"login\"); super.addViewControllers(registry);&#125; 在这里重写addViewControllers方法，并不会覆盖WebMvcAutoConfiguration中的addViewControllers（在此方法中，Spring Boot将“/”映射至index.html），这也就意味着我们自己的配置和Spring Boot的自动配置同时有效，这也是我们推荐添加自己的MVC配置的方式。 拦截器addInterceptors拦截器在我们项目中经常使用的，这里就来介绍下最简单的判断是否登录的使用。要实现拦截器功能需要完成以下2个步骤： 创建我们自己的拦截器类并实现 HandlerInterceptor 接口 重写WebMvcConfigurerAdapter中的addInterceptors方法把自定义的拦截器类添加进来 第一步：自定义拦截器 1234567891011121314151617181920212223242526@Configurationpublic class InvokingInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; User user = (User)request.getSession().getAttribute(\"user\"); if (user == null) &#123; response.sendRedirect(\"login\"); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 这里我们简单实现了根据session中是否有User对象来判断是否登录，为空就跳转到登录页，不为空就通过。 第二步：重写WebMvcConfigurerAdapter中的addInterceptors方法 12345678910111213/** * 拦截器 * @param registry */@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new InvokingInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/toLogin\",\"/login\"); super.addInterceptors(registry);&#125; 这样拦截器就写完了。 页面登录代码 html: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/meta&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form &gt; &lt;input type=\"text\" id = \"userName\" required=\"required\" placeholder = \"用户名\"/&gt; &lt;input type=\"password\" id = \"password\" required=\"required\" placeholder = \"密码\"/&gt; &lt;button type = \"submit\" id = \"toLogin\" &gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/login.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js: 1234567891011121314151617$(\"#toLogin\").click(function () &#123; $.ajax(&#123; type : \"post\", url : \"/toLogin\", data : &#123; \"userName\" : $(\"#userName\").val(), \"password\" : $(\"#password\").val() &#125;, success : function(data) &#123; if (data.result == \"0\") &#123; window.location.href =\"/learn\"; &#125; else &#123; alert(\"账号密码不能为空！\"); &#125; &#125; &#125;);&#125;) 控制层代码 1234567891011121314151617181920212223242526272829303132333435363738394041@Controllerpublic class IndexController &#123; /** * 登陆 * @param request * @return */ @RequestMapping(value = \"/toLogin\", method = RequestMethod.POST) @ResponseBody public Map&lt;String, String&gt; login(HttpServletRequest request, String userName, String password)&#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); if(!userName.equals(\"\") &amp;&amp; password!=\"\")&#123; User user =new User(userName,password); request.getSession().setAttribute(\"user\",user); map.put(\"result\",\"0\"); &#125;else&#123; map.put(\"result\",\"-1\"); &#125; return map; &#125; @RequestMapping(\"/learn\") public ModelAndView index ()&#123; List&lt;LearnThymeleaf&gt; learnList =new ArrayList&lt;&gt;(); LearnThymeleaf bean =new LearnThymeleaf(\"官方参考文档\",\"Spring Boot Reference Guide\",\"地址1\"); learnList.add(bean); bean =new LearnThymeleaf(\"官方SpriongBoot例子\",\"官方SpriongBoot例子\",\"地址2\"); learnList.add(bean); bean =new LearnThymeleaf(\"龙国学院\",\"Spring Boot 教程系列学习\",\"地址3\"); learnList.add(bean); bean =new LearnThymeleaf(\"潇洒的博客\",\"SpringBoot系列\",\"地址4\"); learnList.add(bean); bean =new LearnThymeleaf(\"程序猿DD\",\"Spring Boot系列\",\"地址5\"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView(\"/index\"); modelAndView.addObject(\"learnList\", learnList); return modelAndView; &#125;&#125; 这样访问的时候，如果未登录就会跳转到login.html页面，而访问 http://localhost:8080/login 不会被拦截。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（三）之 Thymeleaf篇","slug":"SpringBoot（三）之 Thymeleaf篇","date":"2017-12-04T08:07:18.000Z","updated":"2017-12-05T06:36:26.100Z","comments":true,"path":"2017/12/04/SpringBoot（三）之 Thymeleaf篇/","link":"","permalink":"http://litxiaosa.me/2017/12/04/SpringBoot（三）之 Thymeleaf篇/","excerpt":"在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？ Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf（官方推荐） FreeMarker Velocity Groovy Mustache","text":"在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？ Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf（官方推荐） FreeMarker Velocity Groovy Mustache 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates Thymeleaf模版Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;artifactId&gt;&lt;/dependency&gt; 示例页面模板：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;learn thymeleaf&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center;margin:0 auto;width: 500px; \"&gt; &lt;h1&gt;SpringBoot系列&lt;/h1&gt; &lt;table width=\"100%\" border=\"1\" cellspacing=\"1\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;系列名称&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"learn : $&#123;learnList&#125;\"&gt; &lt;td th:text=\"$&#123;learn.author&#125;\"&gt;潇洒&lt;/td&gt; &lt;td th:text=\"$&#123;learn.title&#125;\"&gt;SpringBoot系列&lt;/td&gt; &lt;td th:text=\"$&#123;learn.url&#125;\"&gt;点我&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：通过xmlns:th=”http://www.thymeleaf.org“ 命令空间，将静态页面转换为动态的视图，需要进行动态处理的元素将使用“th:”前缀。 编写controller:123456789101112131415161718192021@Controllerpublic class IndexController &#123; @RequestMapping(\"/\") public ModelAndView index ()&#123; List&lt;LearnThymeleaf&gt; learnList =new ArrayList&lt;&gt;(); LearnThymeleaf bean =new LearnThymeleaf(\"官方参考文档\",\"Spring Boot Reference Guide\",\"地址1\"); learnList.add(bean); bean =new LearnThymeleaf(\"官方SpriongBoot例子\",\"官方SpriongBoot例子\",\"地址2\"); learnList.add(bean); bean =new LearnThymeleaf(\"龙国学院\",\"Spring Boot 教程系列学习\",\"地址3\"); learnList.add(bean); bean =new LearnThymeleaf(\"潇洒的博客\",\"SpringBoot系列\",\"地址4\"); learnList.add(bean); bean =new LearnThymeleaf(\"程序猿DD\",\"Spring Boot系列\",\"地址5\"); learnList.add(bean); ModelAndView modelAndView = new ModelAndView(\"/index\"); modelAndView.addObject(\"learnList\", learnList); return modelAndView; &#125;&#125; 如果直接打开html页面展现下面的内容 但是启动程序后，访问 http://localhost:8080/ 则是展示Controller中的值，做到了不破坏HTML自身内容的数据逻辑分离。 如果报错404， 看一下Thymeleaf是否引入到了maven里。 更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 1234567891011121314151617181920212223242526272829303132333435#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #在展示之前检查模板是否存在。spring.thymeleaf.check-template=true#检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true #模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot (二) 之 配置文件详解","slug":"SpringBoot  (二) 之 配置文件详解","date":"2017-12-04T06:07:18.000Z","updated":"2017-12-05T07:34:01.626Z","comments":true,"path":"2017/12/04/SpringBoot  (二) 之 配置文件详解/","link":"","permalink":"http://litxiaosa.me/2017/12/04/SpringBoot  (二) 之 配置文件详解/","excerpt":"相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在pom.xml中引入模块化的Starter POMs，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。","text":"相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在pom.xml中引入模块化的Starter POMs，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里： 12com.xiaosa.name = \"xiaosa\"com.xiaosa.title = \"SpringBoot\" 然后通过@Value(&quot;${属性名}&quot;)注解来加载对应的配置属性，为了方便我们依然在启动类里写如下代码： 123456789@Value(\"$&#123;com.xiaosa.name&#125;\")private String name;@Value(\"$&#123;com.xiaosa.title&#125;\")private String title;@RequestMapping(\"/\") public String hexo()&#123; return name+\",\"+title; &#125; 我们启动工程输入http://localhost:8080 就可以看到打印了”xiaosa,SpringBoot” 在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置： 123com.xiaosa.name=xiaosacom.xiaosa.title=StringBootcom.xiaosa.desc=$&#123;com.xiaosaname&#125;正在努力学$&#123;com.xiaosa.title&#125; 使用随机数在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。 12345678910# 随机字符串com.xiaosa.value=$&#123;random.value&#125;# 随机intcom.xiaosa.number=$&#123;random.int&#125;# 随机longcom.xiaosa.bignumber=$&#123;random.long&#125;# 10以内的随机数com.xiaosa.test1=$&#123;random.int(10)&#125;# 10-20的随机数com.xiaosa.test2=$&#123;random.int[10,20]&#125; 多环境配置我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-test.properties：测试环境 application-prod.properties：生产环境 至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。 如：spring.profiles.active=test就会加载application-test.properties配置文件内容 还可以给不同的环境添加不同的端口属性,例如： 1server.port=8081 按照上面的实验，可以如下总结多环境的配置思路： application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置 application-{profile}.properties中配置各个环境不同的内容 通过命令行方式去激活不同环境的配置,例如： 1spring.profiles.active=dev","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"SpringBoot（一）之 快速入门","slug":"SpringBoot（一）之 快速入门","date":"2017-12-01T01:54:26.000Z","updated":"2017-12-04T06:21:56.909Z","comments":true,"path":"2017/12/01/SpringBoot（一）之 快速入门/","link":"","permalink":"http://litxiaosa.me/2017/12/01/SpringBoot（一）之 快速入门/","excerpt":"本系列基于：IDEA、JDK8、SprigBoot1.5.9。通常我们推荐使用JDK8 使用Intellij中的Spring Initializr来快速构建Spring Boot工程初始化Spring Boot项目 点击Create New Project，我们可以看到如下图所示的创建功能窗口。其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址，所以这里创建的工程实际上也是基于它的Web工具来实现的。","text":"本系列基于：IDEA、JDK8、SprigBoot1.5.9。通常我们推荐使用JDK8 使用Intellij中的Spring Initializr来快速构建Spring Boot工程初始化Spring Boot项目 点击Create New Project，我们可以看到如下图所示的创建功能窗口。其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址，所以这里创建的工程实际上也是基于它的Web工具来实现的。 点击Next，等待片刻后，我们可以看到如下图所示的工程信息窗口，在这里我们可以编辑我们想要创建的工程信息。其中， Group 一般是公司名字的反写，也可以自己随意Artifact: 你这个项目叫什么Type可以改变我们要构建的工程类型，比如：Maven、Gradle；Language可以选择：Java、Groovy、Kotlin。 点击Next，进入选择Spring Boot版本和依赖管理的窗口。在这里值的我们关注的是，它不仅包含了Spring Boot Starter POMs中的各个依赖，还包含了Spring Cloud的各种依赖。 我们还可以选择SpringBoot的版本。 这个我们勾选了web，你也可以根据自己的需求勾选。点击Next，进入最后关于工程物理存储的一些细节。最后，点击Finish就能完成工程的构建了。 项目结构 如你所见，项目里面基本没有代码，除了几个空目录外，还包含如下几样东西。 pom.xml：Maven构建说明文件。 DemoApplication：一个带有main()方法的类，用于启动应用程序（关键）。 DemoApplicationTests：一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文。 application.properties：一个空的properties文件，你可以根据需要添加配置属性。 应用入口类 DemoApplication是一个很关键的启动类，程序的入口就是这里,为了演示简单，我们不再新建控制类，而是直接在这个入口类中编写，添加@RestController以及index方法，如下： @SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置。后续讲解原理的时候再深入介绍。 main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。 @RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 启动这个最简单的Web项目，他有三种方法。 DemoApplication的main方法启动，上边个标红的和下面那个标红的是一样的。 使用命令 mvn spring-boot:run”在命令行启动该应用，IDEA中该命令在如下位置： 运行mvn package进行打包时，会打包成一个可以直接运行的 JAR 文件，使用java -jar命令就可以直接运行。 这里是SpringBoot的启动标志 打开浏览器访问http://localhost:8080, 你就能看到页面显示Hello Spring Boot效果了，一个简单的Web的项目就是如此简单。","categories":[{"name":"SpringBoot系列","slug":"SpringBoot系列","permalink":"http://litxiaosa.me/categories/SpringBoot系列/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litxiaosa.me/tags/SpringBoot/"}]},{"title":"学习Git（五）之 搭建Git服务器","slug":"学习Git（五） 之 搭建Git服务器","date":"2017-11-29T08:40:46.000Z","updated":"2017-12-04T03:06:22.665Z","comments":true,"path":"2017/11/29/学习Git（五） 之 搭建Git服务器/","link":"","permalink":"http://litxiaosa.me/2017/11/29/学习Git（五） 之 搭建Git服务器/","excerpt":"在之前的学习中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。","text":"在之前的学习中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器。我是在VMware虚拟机上装了一个CentOS 如果你装的是Ubuntu或者其他的，安装命令可能会不同。这个要注意一下。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git: 1sudo yum install git 如果安装不上可能是网络没配好，找到这个下面这个文件 看一下标红的是不是no,如果是,该为yes。再执行上边那个操作就可以了。 第二步，创建证书： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个。 git和 .ssh/keys是自己手动创建的，我的创建在了root目录下。 创建命令是： 12mkdir gitmkdir .ssh 然后给这个目录对应的权限： 1chmod 700 .ssh/ 再cd .ssh 创建 keys 文件： 1touch keys 然后给这个文件对应的权限 1chmod 600 keys 接着就是把所有的公钥导入了。 第三步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/root/lean.git，在/root目录下输入命令： 1sudo git init --bare lean.git 第四步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： 1git clone git@server:/root/lean.git @server: 对应你们git服务器的ip地址。 剩下的推送就简单了。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（四）之 分支管理","slug":"学习Git（四） 之 分支管理","date":"2017-11-29T02:22:33.000Z","updated":"2017-12-04T03:14:52.371Z","comments":true,"path":"2017/11/29/学习Git（四） 之 分支管理/","link":"","permalink":"http://litxiaosa.me/2017/11/29/学习Git（四） 之 分支管理/","excerpt":"分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！","text":"分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 创建与合并分支首先，我们创建dev分支，然后切换到dev分支, 当然了，要在你本地的仓库目录下： 1git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： 12git branch devgit checkout dev 然后，用git branch命令查看当前分支： 1git branch git branch 命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对demo.txt做个修改，加上 haha 然后提交 12git add demo.txtgit commit -m \"branch test\" 现在，dev分支的工作完成，我们就可以切换回master分支： 1git checkout master 切换回master分支后，再查看一个demo.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： 1git merge dev 合并完成后，就可以放心地删除dev分支了： 1git branch -D dev 删除后，查看branch，就只剩下master分支了： 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的 准备新的feature1分支，继续我们的新分支开发： 1git checkout -b feature1 再次修改demo.txt, 增加： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 12git add demo.txtgit commit -m \"AND simple\" 切换到master分支： 1git checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把demo.txt文件的最后一行替换为: 1Creating a new branch is quick &amp; simple 提交 12git add demo.txt git commit -m \"&amp; simple\" 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1git merge feature1 果然冲突了！Git告诉我们，demo.txt文件存在冲突，必须手动解决冲突后再提交。我们可以直接查看demo.txt的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 再提交： 12git add demo.txtgit commit -m \"conflict fixed\" 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 最后，删除feature1分支： 1git branch -D feature1 工作完成。 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在``master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 1git remote 或者，用git remote -v显示更详细的信息 1git remote -v 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1git push origin master 如果要推送其他分支，比如dev，就改成： 1git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1git clone https://github.com/Litxiaosa/learnGit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 1git branch 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，(我们在里面添加了hello world)然后，时不时地把dev分支push到远程： 123git add demo.txtgit commit -m \"add hello world\"git push origin dev 可能让你输入你的GitHub的用户名和密码 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送,我们添加了一句：hello git 123git add demo.txtgit commit -m \"add hello git\"git push origin dev 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 1git pull origin dev git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push。 因此，多人协作的工作模式通常是这样： 首先，可以试图用 git push origin branch-name 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用 git push origin branch-name 推送就能成功！ 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 git branch 查看当前分支 git branch -v 查看每一个分支的最后一次提交 git branch -a 查看本地和远程分支的情况 git branch –merged 查看已经与当前分支合并的分支 git branch –no-merged 查看已经与当前分支未合并的分支 git branch -r 查看远程分支 git branch dev 创建分支 dev git checkout dev 切换到分支dev git checkout -b dev 创建并切换分支dev git merge dev 名称为dev的分支与当前分支合并 git branch -d dev 删除分支dev","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（三） 之 远程仓库","slug":"学习Git（三） 之 远程仓库","date":"2017-11-28T09:58:43.000Z","updated":"2017-12-04T03:43:30.216Z","comments":true,"path":"2017/11/28/学习Git（三） 之 远程仓库/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（三） 之 远程仓库/","excerpt":"Git本地操作的熟练了后，就可以尝试连接远程仓库了，完全可以自己搭建一台运行Git的服务器，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交，不过现阶段，我们不打算这么搞。目前国内外比较出名的提供Git仓库远程托管的有国外的GitHub，国内的开源中国以及coding。这里我以GitHub为例子介绍如何操作远程仓库。","text":"Git本地操作的熟练了后，就可以尝试连接远程仓库了，完全可以自己搭建一台运行Git的服务器，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交，不过现阶段，我们不打算这么搞。目前国内外比较出名的提供Git仓库远程托管的有国外的GitHub，国内的开源中国以及coding。这里我以GitHub为例子介绍如何操作远程仓库。 现在的情景是，你已经在本地创建了一个Git仓库，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。 添加远程仓库 首先，登陆GitHub，然后，在右上角找到“new repository”按钮，创建一个新的仓库： 在Repository name填入learnGit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learnGit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的GitRepository仓库下运行命令： 1git remote add origin git@github.com:Litxiaosa/learnGit.git 请千万注意，把上面的Litxiaosa替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上 1git push -u origin master 可以看到，你本地的代码就推送到远程仓库了推送成功后 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令 1git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 从远程库克隆我们讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库 1sudo git clone https://github.com/Litxiaosa/gitskills.git 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 小结 要关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git 关联后，使用命令 git push -u origin master 第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令 git push origin master 推送最新修改","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（二）之 暂存区","slug":"学习Git（二）之 暂存区","date":"2017-11-28T08:55:30.000Z","updated":"2017-12-04T03:49:30.821Z","comments":true,"path":"2017/11/28/学习Git（二）之 暂存区/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（二）之 暂存区/","excerpt":"工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。","text":"工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的GitRepository文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面说了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 撤销操作 如果你文件只是在工作区修改了，但是还没提交到暂存区的时候，你可以用下面的命令来撤销。 1git checkout -- [file] 比如，你有一个文件叫demo.txt, 里面的内容为：Today is Tuesday。 并且这句话已经提交到暂存区。 此时，你又在工作区修改了demo.txt 这个文件， 内容增加了一句：I don&#39;t know what to say 然后执行git checkout -- demo.txt命令,你会发现demo.txt内容又变成Today is Tuesday了。 1git checkout -- demo.txt git checkout -- file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。 假如你文件在工作区修改了,并且也执行 git add 命令提交给暂存区了，但是，还没有执行commit操作。那么执行上面的 git checkout -- [file] 已经无效了，因为工作区跟暂存区已经一样了，再怎么覆盖内容也一样，这时候就应该使用 git reset HEAD 命令来撤销。 1git reset HEAD demo.txt 还记得如何丢弃工作区的修改吗？ 1git checkout -- demo.txt 回头看看添加的内容是不是又回滚了？ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"学习Git（一）之 快速入门","slug":"学习Git（一）之 入门","date":"2017-11-28T06:14:43.000Z","updated":"2017-12-04T04:29:00.398Z","comments":true,"path":"2017/11/28/学习Git（一）之 入门/","link":"","permalink":"http://litxiaosa.me/2017/11/28/学习Git（一）之 入门/","excerpt":"本系列文章基于Mac系统 之前自己搭建博客的时候使用到GitHub，需要使用git进行版本控制，现在很多公司也在使用Git，发现Git很棒，于是学习了解一下Git。这只是我自己的学习笔记，如果你是大神，请你不吝赐教，如果你也是小白，希望这系列文章能帮到你。","text":"本系列文章基于Mac系统 之前自己搭建博客的时候使用到GitHub，需要使用git进行版本控制，现在很多公司也在使用Git，发现Git很棒，于是学习了解一下Git。这只是我自己的学习笔记，如果你是大神，请你不吝赐教，如果你也是小白，希望这系列文章能帮到你。 安装并配置Git 要使用Git，第一步当然是安装Git了。 首先，打开终端输入一下命令，看你是否安装了Git 1git --version 如果没有安装，那么请下载安装 Git客户端， 选择你自己的系统下载安装即可。 当安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global user.name 你的名字git config --global user.email 你的邮箱 如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不使用 --global 选项的命令来配置。 检查配置信息 如果你不确定你的信息是不是配置成功了，可以输入一下命令查看 1git config --list 如果你觉得返回的信息太多，也可以输入git config &lt;key&gt;： 查询指定的配置，例如: 12git config user.name git config user.email 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录，直接新建文件夹即可（我的起名字叫：GitRepository），然后cd 到该文件夹下，执行下面的命令 1git init 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 提交文件到版本库上面把git仓库搭建好了，现在就来试试添加文件到版本库里面。 创建一个txts文档起名叫做demo.txt，往里面添加一点内容 Hello Git 注意:这里需要文件是UTF-8格式的。 一定要放到GitRepository目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： 1git add demo.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： 1git commit -m \"first commit\" -m 参数是用来注释你提交的信息的，这样以后才知道这次提交更改了什么 查看当前新增或者修改的文件实际使用中你不止提交一个文件，或新增或修改多个文件，可能时间一久就忘了有多少文件需要提交。 这里模拟一下，首先新建一个hello.txt的文件，然后修改demo.txt内容，添加一句come on 这样就有2个文件需要提交了。 我们使用git status命令来查看当前状态,是否有未提交的文件 1git status 如图，可以看到一个demo.txt被修改过了，但还没有准备提交的修改，另外一个是Untracked files: hello.txt，表示新增的文件。 这时候准备把上面2个文件都提交，使用命令: 12git add demo.txtgit add hello.txt 或者你嫌弃文件太多，一次次add感觉很麻烦，那么可以试试使用`git add .`` 提交，.表示提交当前目录所有文件 12git add .git commit -m \"second commit\" 提交后再使用git status命令查看下 如图，可以看到文件提交到仓库了，并且git status后提示nothing to commit, working directory clean，说明当前没有需要提交的修改，工作目录是干净。 查看历史提交记录有时候你想看看之前提交的历史纪录~那么就需要使用到下面的命令： 1git log 如图，可以看到我们提交的2次历史，first commit和 second commit。历史纪录是根据时间倒叙排列的。 如果觉得代码太多了，加点过滤就行 1git log --pretty=oneline 回滚版本现在我们准备把demo.txt回退到上一个版本，也就是“first commit”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交2c49a55···9a9a13c（注意我的提交ID和你的肯定不一样）， 就是上图中那一大长串字符，上一个版本就是 HEAD^，上上一个版本就是 HEAD ^^，当然往上100个版本写 100个^ 比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“second commit”回退到上一个版本“first commit”，就可以使用git reset命令： 1git reset --hard HEAD^ 看看第二次提交的 helllo.txt 是不是不见了，demo.txt 里面的内容是不是也变了？ 好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个second commit的commit id是2c49a55···9a9a13c，于是就可以指定回到未来的某个版本： 1git reset --hard 2c49a5503041f562e8dfbf 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 果然， 老子又回来了！ 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ Git提供了一个命令git reflog用来记录你的每一次命令： 1git reflog （注：我没有再次做回滚操作） commit id 又出来了，现在，你又可以到未来了。就问你厉不厉害！ 结束语好了，这一篇，我们学了Git的安装和一些基本命令操作，差不多算入门了，接下去就是继续深入学习了。","categories":[{"name":"学习Git","slug":"学习Git","permalink":"http://litxiaosa.me/categories/学习Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://litxiaosa.me/tags/Git/"}]},{"title":"姑苏有钟声","slug":"姑苏有钟声","date":"2017-10-31T03:51:28.000Z","updated":"2017-12-21T12:28:17.022Z","comments":true,"path":"2017/10/31/姑苏有钟声/","link":"","permalink":"http://litxiaosa.me/2017/10/31/姑苏有钟声/","excerpt":"如果你听歌可眼红，何以待她好偏不懂。","text":"如果你听歌可眼红，何以待她好偏不懂。 她不会像白富美那样偶尔流露出一丝惹人厌的高傲，更不会像女屌丝那样做派发指 长相抱歉。 她在自己生活的圈子里优雅的生活，不会默默无闻。 她长得不算差，打扮得干干净净，或许不会穿的跟颁奖礼一般，但绝对会扬长避短穿出别有一番韵味。她更绝不会不自量力搭配没品。 她或许温婉，或许贤良，或许天真，或许任性，但这都不重要，重要的是，她很温暖，很安心。 可能她是你的同学，又或者是校友，又或者是陌生人，反正就在那个电光火石般的一瞬，你像一朵青春萌动的少年，看见让自己眼前一亮的女生，一种莫名的冲动，发自内心，倚仗着荷尔蒙喷薄而出。 你像一般电视剧演的那样，像一个侦探一样，调动了一切手段渠道，用此处略去七十八个字儿的方法彻底地认识了她。 上天会怜悯那些绞尽脑汁的虔诚孩子，他会轻易地突破第四维度，将两条平行线改变了轨迹，交在了一起。 你只知道在继续省略十万八千个字之后她会叫你傻逼会叫你神经病，会在你让她早点睡觉的时候跟你说嗯。 在你寂寞的单身的想要恋爱的时候，你会发现她总会匪夷所思地出现在你的脑海。 她或许不会天天叫你早睡早起不要熬夜，或许也不记得有纪念意义的日子，或许更不会记得你的生日，你的爱好，她也不会认识太多你身边的朋友，或许连相熟也称不上。但你会。 有时候你也会约她，她大多会欣然答应，但恪守本分，不远不近保持着距离，若即若离。 你开始期待甚至盼望每天与她的相见，就像陈小春唱的，她像个天仙，她太美了。我那么平凡…… 然后小灯泡一亮，叮得一声：她不讨厌我，肯定喜欢我～ 傻逼了吧。 也许对于她来说，你只是一个可有可无的存在，多一个不多，少一个不少。这只是她的一种教养，一个习惯，或者一种本能而已。你不能否认就是有这样的姑娘，自带女神光环，她们能让周围的人都如沐春风，让异性为之深深地吸引。 你跟她身边其余的异性一样，就像女生面对淘宝满屏的东西，你不能说她讨厌你，但确实也挑不到喜欢的。 每个男生骨子里爆棚的自信心也最容易高估自己，而这些恰恰会让感觉良好的少年们自作多情自不量力自欺欺人自讨苦吃自掘坟墓自食其果自取灭亡自作孽不可活。 你把这个感觉转嫁到了她身上，开始无可救药地以为爱上了。 你开始为了她的每句话揣测推断，开始去思考她每一条状态每一个签名，即使像今天我出去玩的好开心如此这般的毫无意义。 你开始每天守在电脑前，看着她的头像亮起来，然后去跟她闲扯去逗她笑，尽所能地去让你开心，快乐。你每次看到冰冷的屏幕上出现她打出来的哈哈或者嘿嘿，你总是盯着屏幕傻呵呵地咧嘴笑。你会反复在脑海里意淫般地勾画出你们俩个人在一起的情形。 你会抵挡不住见她的冲动不在乎跑多少公里，看到她的时候你会觉得这几千公里跟孙猴子一个筋斗那样不值一提。你会挖空心思地对她好，好到用语言描述出来都略显单薄但是无用。好到连你们周围的人都感觉到窒息，直到后来你才知道，太把优柔寡断投鼠忌器的磨叽当慎重的人，往往却会栽到自作聪明作茧自缚这几个字上。 小黄人喜欢的不是apple，而是banana。 对了，你是不是还会像个护食的汪星人一般，假如别的男生若是和她多聊几句，就在脑子里无数次描绘那男的被爆菊的惨状。 你看，说你神经病你还不愿意，你这就是神经病。 你还时常感谢上苍，他把两条平行线交汇在一起。但这只会让你记得交汇那一瞬她蹦蹦跳跳像个小猴子般的身影，和你脑子里那被风吹起的刘海。 你来到她的城市，走过她来时的路，然后，相交线就会渐行渐远。 到这里，你心里一定会跟千万只草泥马奔腾而过一样吧，老天爷办事儿，远他妈的不是你想的路数。 在我收集的剪报里，有大致如下几段话：你那时应该知道，如果一个人真的爱你，她一定会告诉你，至少会表现出来，而不是让你自己胡乱猜测的被感觉左右。和这位姑娘相处，本身就是一件很美好的事。你只是没给自己留一点可进退的余地，后悔莫及。你因为一厢情愿，搭上了自己的一片真心。没人不怪你看不透，只是因为你太需要爱。当你明白你再怎么做也无力回天的时候，还是感觉这东西害了你。这位姑娘对你没感觉，而感觉是个奇妙和淘气的小家伙。 当你觉得一个人千般好万般好，那也许是迷恋。当你觉得她有时候很呆傻，但却傻的非常可爱，那可能是喜欢。当你看到她的每一面，包括最差的，但还不想离开她，那大概是习惯。爱没法去描述，但你永远不会错认。 爱就是内心的召唤而已，夜里睡不着想到她时那满心酸楚的悸动，跟她说话聊天字斟句酌的计较，面对她的时候那喷薄而出的欲望，都是爱情的原因。 那时有一个姑娘，懂你所有，出现在你的生命里。 只是错误的时间，错误的地点，遇到错误的人，却产生了对的感觉。 只是她身上的温暖蛊惑了你，让你误以为那就是爱情。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云，摘抄","slug":"不知所云，摘抄","permalink":"http://litxiaosa.me/tags/不知所云，摘抄/"}]},{"title":"阿里巴巴Java开发规约插件","slug":"阿里巴巴Java开发规约插件","date":"2017-10-25T03:44:41.000Z","updated":"2017-12-04T02:17:10.465Z","comments":true,"path":"2017/10/25/阿里巴巴Java开发规约插件/","link":"","permalink":"http://litxiaosa.me/2017/10/25/阿里巴巴Java开发规约插件/","excerpt":"阿里巴巴Java开发手册在介绍这款插件之前，先说一下《阿里巴巴Java开发手册》。2017年初，阿里巴巴官方首次公开Java代码规范标准手册，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本，我第二时间（刚公开时我不知道。我也很无奈啊）下载来看。对我个人而言帮助挺大的，渐渐改掉了我好多编码的坏习惯。这个手册的愿景是这样的： “统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本”。","text":"阿里巴巴Java开发手册在介绍这款插件之前，先说一下《阿里巴巴Java开发手册》。2017年初，阿里巴巴官方首次公开Java代码规范标准手册，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本，我第二时间（刚公开时我不知道。我也很无奈啊）下载来看。对我个人而言帮助挺大的，渐渐改掉了我好多编码的坏习惯。这个手册的愿景是这样的： “统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本”。 到现在为止已经更新迭代了三个版本。也是阿里官方对外发布的最后一个PDF版本，我觉得是值得收藏的。 插件简单介绍阿里巴巴基于手册内容，研发了一套自动化的IDE检测插件（IDEA、Eclipse）， 该插件在扫描代码后，将不符合《手册》的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能，提升代码质量，提高团队研发效能。 代码已经开源，GitHub：https://github.com/alibaba/p3c 插件简单教程打开 IDEA 搜索”alibaba”, 你就可以看到返回结果里有”Alibaba Java Coding Guidelines”。我这里已经下载过了。直接安装重启编译器就好， 在项目上右键就可以看到这两个功能，点绿色按钮就扫面本项目全部的文件，如果只想扫描当前的文件，那就在当前文件上右键，那么它只扫描当前的文件。 前面说的都是手动监测，该插件也提供了实时监测的功能，此功能是默认开启的，在你编写代码时就会实时监测，一旦有不符合规范的语句就会出现错误提示。 扫描代码后，不符合规约的代码会按Blocker/Critical/Major三个等级显示在下方面板中，左边是扫描出的不符合规范的代码，依次点进去可以看到是代码的多少行出现了规约问题以及哪一个规约问题，右边则是规约的详细描述及实例代码。不仅如此，右边还可以点击自动改正代码，但是并不是所有的问题都可以。有些还是需要手动改的。 结束语用了几天，说一下感受，总体而言对于我个人而言还是有帮助的，它可以帮助我慢慢改掉我编码中的坏习惯，帮助我在编码规范方面成长。那么用了它是不是会让我们代码少一些bug呢？很显然不是，它只是一个监测和提示工具。最后还得靠我们自己。 多说一句，该插件所用的是阿里巴巴公司的开发规范，肯定会与其他的规范有出入。如果觉得不适合公司或者自己的开发习惯，那就没必要用了。适合自己的最好。","categories":[{"name":"编码规范插件","slug":"编码规范插件","permalink":"http://litxiaosa.me/categories/编码规范插件/"}],"tags":[{"name":"编码规范插件","slug":"编码规范插件","permalink":"http://litxiaosa.me/tags/编码规范插件/"}]},{"title":"solr的配置和简单应用","slug":"solr的配置和简单应用","date":"2017-08-24T02:48:25.000Z","updated":"2018-01-09T12:43:28.334Z","comments":true,"path":"2017/08/24/solr的配置和简单应用/","link":"","permalink":"http://litxiaosa.me/2017/08/24/solr的配置和简单应用/","excerpt":"本文基于solr-6.6 、 tomcat-9、 jdk-1.8 solr下载完成以后解压即可。 在tomcat上安装solr 把solr目录下的server/solr-webapp/webapp目录拷贝到tomcat/webapps的目录下,并且重命名为solr（任意名字）","text":"本文基于solr-6.6 、 tomcat-9、 jdk-1.8 solr下载完成以后解压即可。 在tomcat上安装solr 把solr目录下的server/solr-webapp/webapp目录拷贝到tomcat/webapps的目录下,并且重命名为solr（任意名字） 将solr\\server\\lib\\ext下的所有jar包，以及sol\\server\\lib下以metrics开头的jar包复制到tomcat\\webapps\\solr\\WEB-INF\\lib下 在tomcat\\webapps\\webapp\\WEB-INF中，新建classes文件夹，将solr\\server\\resources下的log4j.properties文件拷贝到里面，修改里面的solr.log=输出日志的路径（请使用/分割，注意不要有中文，避免乱码问题） 将solr\\server中的solr目录拷贝到任意地方，重命名为solrHome 修改tomcat\\webapps\\solr\\WEB-INF中的web.xml文件 并且注释调以下代码 启动tomcat访问localhost:8080/solr/index.html 目前solrHome目录是空的，我们在solrHome目录下创建一个空文件夹core1，这个就是我们的一个实例。 把solr/server/solr下的文件复制到solrHome目录下。 在solr的管理控制台界面，添加一个core1 这下就创建成功了一个实例core1 ,注意，如果无法创建core,看一下是否执行了第8步，网上说这是bug Ik中文分词器 下载IK分词器 将ik-analyzer-solr5-5.x.jar这个jar包放入tomcat/webapps/solr/WEB-INF/lib里面( 千万不要复制到tomcat/lib中，这样会找不到lucene的类) 将IKAnalyzer.cfg.xml，ext.dic（搜狗的扩展词库），stopword.dic放在tomcat\\webapps\\solr\\WEB-INF\\classes目录下 打开solrHome/core1/conf/managed-schema文件 添加以下配置 123456&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer type=\"index\" useSmart=\"false\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\" /&gt; &lt;analyzer type=\"query\" useSmart=\"true\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\" /&gt;&lt;/fieldType&gt; 重启tomcat，即可看到text_ik分词 域 插入的文档必须与域相匹配 域，它在solr中有特定的含义，就类似于数据库表中的列 ，规范着写入的数据。我们先来做个例子。 可以看到，这次插入的文档，有id，title。当然，在solr中，每一条记录都必须有着一个唯一的id，它就类似数据库中的主键，不可重复。这条记录的插入是成功的。 但是，如果我把title改成title1,这就与定义的字段不一样了，就会报错,可以看到，这里提示，未知的字段 title1. 域的定义 field 先拿出来一条配置来看一下 1&lt;field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" /&gt; 首先，我们认识一下这些属性 name: 域名type: 域的类型，必须匹配类型，不然会报错indexed: 是否要做索引stored: 是否要储存required: 是否必填multiValued：是否多值，如果设置为多值，里面的值就会采用数组的方式储存 动态域 dynamicField 同样，我们拿出一条来看 1&lt;dynamicField name=\"*_i\" type=\"string\" indexed=\"true\" stored=\"true\" multiValued=\"true\" /&gt; 那么，什么是动态域呢？就是这个域的名称，是由表达式组成的，只要名称满足了这个表达式，就可以用这个域 同样的认识一下这些属性 name: 域的名称，该域的名称是通过一个表达式来指定的，只要符合这这个规 则，就可以使用这个域 type: 对应的值类型，相应的值必须满足这个类型，不然就会报错indexed: 是否要索引stored: 是否要存储…其它的属性与上边的一致 主键域 uniqueKey 1&lt;uniqueKey&gt;id&lt;/uniqueKey&gt; 指定一个唯一的主键，每一个文档中，都应该有一个唯一的主键，这个值不要随便改 复制域 copeField 12&lt;copyField source=\"cat\" dest=\"text\"/&gt; &lt;field name=\"text\" type=\"string\" indexed=\"true\" stored=\"true\" multiValued=\"true\"/&gt; source: 源域dest: 目标域 复制域，将源域的内容复制到目标域中 注意：目标域必须是允许多值的，如下，multiValued必须为true，因为可能 多个源域对应一个目标域，所以它需要以数组来存储 域的类型 同样的给出一段配置 12345678910111213141516&lt;fieldType name=\"text_general\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer class=\"solr.StandardTokenizerFactory\"/&gt; &lt;filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" /&gt; &lt;!-- in this example, we will only use synonyms at query time &lt;filter class=\"solr.SynonymFilterFactory\" synonyms=\"index_synonyms.txt\" ignoreCase=\"true\" expand=\"false\"/&gt;--&gt; &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer class=\"solr.StandardTokenizerFactory\"/&gt; &lt;filter class=\"solr.StopFilterFactory\" ignoreCase=\"true\" words=\"stopwords.txt\" /&gt; &lt;filter class=\"solr.SynonymFilterFactory\" synonyms=\"synonyms.txt\" ignoreCase=\"true\" expand=\"true\"/&gt; &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt; &lt;/analyzer&gt;&lt;/fieldType&gt; 介绍一下这些属性 name: 域的名称class: 指定solr的类型analyzer: 分词器的配置type: index(索引分词器)，query(查询分词器)tokenizer: 配置分词器filter: 过滤器 所有上述域，都可以在solrHome/core1/conf/managed-schema文件里找到。 字段的实际配置首先，打开solrHome/core1/conf/managed-schema文件 我们用field来配置实际的业务字段 上边我们配置了中文分词器，已经配置了一个fieldType的中文分词，所 以我们现在一律用中文分词的域类型 主键的id就不需要配置了，默认已经把id配置为主键了 1&lt;field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" /&gt; 商品名称(需要分词，需要存储) 1&lt;field name=\"product_name\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt; 商品图片(不需要分词，需要存储) 1&lt;field name=\"product_url\" type=\"string\" indexed=\"false\" stored=\"true\"/&gt; 商品价格(不需要分词，需要存储) 1&lt;field name=\"product_price\" type=\"double\" indexed=\"false\" stored=\"true\"/&gt; 商品分类(不需要分词，需要存储) 1&lt;field name=\"product_type\" type=\"int\" indexed=\"false\" stored=\"true\"/&gt; 商品描述(需要分词，需要存储) 1&lt;field name=\"product_description\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt; 复制域的应用 用户在搜索框搜索的时候，有可能输入的是商品名称，也有可能输入的是商品描述，也有可能输入的是一个商品类型，那么这些值的搜索，肯定在后台是对应一个域的，那么既然如此，我们就可以把这些域合并成一个，这样在后台只需要单独的对这一个域进行搜索就可以了。 先定义一个目标域： 1&lt;field name=\"aim\" type=\"text_ik\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/&gt; 复制域，把商品名称，商品描述，商品类型名称复制到上面的这个域中 123&lt;copyField source=\"product_name\" dest=\"aim\"/&gt;&lt;copyField source=\"product_type\" dest=\"aim\"/&gt;&lt;copyField source=\"product_description\" dest=\"aim\"/&gt; dataimport 导入数据库数据solr默认是没有开启dataimport这个功能的，所以我们要经过一点配置来开启它 首先找到solr/dist/solr-dataimporthandler-6.6.0.jar，把这个文件复制到tomcat/webapp/solr/WEB-INF/lib/下(前面拷贝过的忽略此操作)。并且找到相应数据库的驱动包，也同样放到该目录。我这里用的是mysql 的驱动 找到solrHome/core1/conf/solrconfig.xml，并打开，在里面添加一段内容 12345&lt;requestHandler name=\"/dataimport\" class=\"solr.DataImportHandler\"&gt; &lt;lst name=\"defaults\"&gt; &lt;str name=\"config\"&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 找到solr/example/example-DIH/solr/db/conf/db-dataconfig.xml，把其复制到solrHome/core1/conf/下，并改名为data-config.xml, 打开并编辑，修改如下 1234567891011121314151617&lt;dataConfig&gt;&lt;!--这是mmysql的配置--&gt;&lt;dataSource driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/solr\" user=\"你的账号\" password=\"你的密码\"/&gt;&lt;document&gt;&lt;!-- name属性，就代表着一个文档，可以随便命名 --&gt;&lt;!-- query是一条sql，代表在数据库查找出来的数据 --&gt;&lt;entity name=\"product\" query=\"select * from product\"&gt; &lt;!-- 每一个field映射着数据库中列与文档中的域，column是数据库列，name是solr的域(必须是在managed-schema文件中配置过的域才行) --&gt; &lt;field column=\"id\" name=\"id\"/&gt; &lt;field column=\"name\" name=\"product_name\"/&gt; &lt;field column=\"url\" name=\"product_url\"/&gt; &lt;field column=\"price\" name=\"product_price\"/&gt; &lt;field column=\"type\" name=\"product_type\"/&gt; &lt;field column=\"description\" name=\"product_description\"/&gt;&lt;/entity&gt;&lt;/document&gt;&lt;/dataConfig&gt; 重启tomcat， 会看到如下页面 点击蓝色的按钮，则开始导入，导入过程依据数量量的大小，需要的时间也不同，可以点击右边的Refresh status来刷新状态，可以查看当前导入了多少条 solrJ的使用现在说一下使用solrj来维护solr的索引及操作，solrj就是一个java的客户端，是一个jar包的使用，首先引入MAVEN的依赖，solrj的版本号要对应solr的版本号 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;6.6.0&lt;/version&gt;&lt;/dependency&gt; 增加及修改 在solr中，增加与修改都是一回事，当这个id不存在时，则是添加，当这个id存在时，则是修改 123456789101112131415161718192021public class SolrController &#123; private String serverUrl = \"http://10.60.20.152:8080/solr/core1\"; public void save() throws SolrServerException, IOException &#123; //创建 HttpSolrClient client = new HttpSolrClient(serverUrl); SolrInputDocument doc = new SolrInputDocument(); doc.addField(\"id\", \"5008\"); doc.addField(\"product_name\", \"姓名\"); doc.addField(\"product_type\", \"1\"); doc.addField(\"product_url\", \"图片\"); doc.addField(\"product_price\", \"11\"); doc.addField(\"product_description\", \"这是一个测试例子\"); client.add(doc); client.commit(); client.close(); &#125;&#125; 删除索引 1234567891011121314151617181920212223242526public class SolrController &#123;private String serverUrl = \"http://10.60.20.152:8080/solr/core1\";public void delete()throws Exception&#123; HttpSolrClient client = new HttpSolrClient(serverUrl); //1.删除一个 client.deleteById(\"5008\"); //2.删除多个 List&lt;String&gt; ids = new ArrayList&lt;&gt;(); ids.add(\"1\"); ids.add(\"2\"); client.deleteById(ids); //3.根据查询条件删除数据,这里的条件只能有一个，不能以逗号相隔 client.deleteByQuery(\"id:5008\"); //4.删除全部，删除不可恢复 client.deleteByQuery(\"*:*\"); //一定要记得提交，否则不起作用 client.commit(); client.close(); &#125;&#125; 查询 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SolrController &#123;private String serverUrl = \"http://10.60.20.152:8080/solr/core1\";public void search()throws Exception&#123; HttpSolrClient client = new HttpSolrClient(serverUrl); //创建查询对象 SolrQuery query = new SolrQuery(); //q 查询字符串，如果查询所有*:* query.set(\"q\", \"product_name:潇洒\"); //fq 过滤条件，过滤是基于查询结果中的过滤 query.set(\"fq\", \"product_type:1\"); //sort 排序，请注意，如果一个字段没有被索引，那么它是无法排序的 //query.set(\"sort\", \"product_price desc\"); //start row 分页信息，与mysql的limit的两个参数一致效果 query.setStart(0); query.setRows(10); //fl 查询哪些结果出来，不写的话，就查询全部、 // query.set(\"fl\", \"\"); //df 默认搜索的域 query.set(\"df\", \"product_keywords\"); //高亮设置 //开启高亮 query.setHighlight(true); //高亮域 query.addHighlightField(\"product_name\"); //前缀 query.setHighlightSimplePre(\"&lt;span style='color:red'&gt;\"); //后缀 query.setHighlightSimplePost(\"&lt;/span&gt;\"); //执行搜索 QueryResponse queryResponse = client.query(query); //搜索结果 SolrDocumentList results = queryResponse.getResults(); //查询出来的数量 long numFound = results.getNumFound(); System.out.println(\"总查询出:\" + numFound + \"条记录\"); //遍历搜索记录 //获取高亮信息 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : results) &#123; System.out.println(\"商品id:\" + solrDocument.get(\"id\")); System.out.println(\"商品名称 :\" + solrDocument.get(\"product_name\")); System.out.println(\"商品分类:\" + solrDocument.get(\"product_type\")); System.out.println(\"商品价格:\" + solrDocument.get(\"product_price\")); System.out.println(\"商品描述:\" + solrDocument.get(\"product_description\")); System.out.println(\"商品图片:\" + solrDocument.get(\"product_url\")); //输出高亮 Map&lt;String, List&lt;String&gt;&gt; map = highlighting.get(solrDocument.get(\"id\")); List&lt;String&gt; list = map.get(\"product_name\"); if(list != null &amp;&amp; list.size() &gt; 0)&#123; System.out.println(list.get(0)); &#125; &#125; client.close();&#125;&#125; 补充 q - 查询字符串，如果查询所有: (id:1)fq - （filter query）过虑查询，过滤条件，基于查询出来的结果fl - 指定返回那些字段内容，用逗号或空格分隔多个start - 分页开始rows - 分页查询数据sort - 排序，格式：sort=+[,+]… 。示例：（score desc, price asc）表示先 “score” 降序, 再 “price” 升序，默认是相关性降序。fl表示索引显示那些field(表示所有field,如果想查询指定字段用逗号或空格隔开（如：Name,SKU,ShortDescription或Name SKU &gt;ShortDescription【注：字段是严格区分大小写的】）)hl 是否高亮 ,如hl=truehl.fl 高亮field ,hl.fl=Name,SKUhl.simple.pre 高亮前面的格式hl.simple.post 高亮后面的格式","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"http://litxiaosa.me/categories/搜索引擎/"}],"tags":[{"name":"solr","slug":"solr","permalink":"http://litxiaosa.me/tags/solr/"}]},{"title":"浮生若梦","slug":"浮生若梦","date":"2017-07-17T02:44:52.000Z","updated":"2017-12-21T12:27:59.748Z","comments":true,"path":"2017/07/17/浮生若梦/","link":"","permalink":"http://litxiaosa.me/2017/07/17/浮生若梦/","excerpt":"浮生若梦,若梦非梦,浮生何如,如梦之梦 ——— 庄子《如梦之梦》 你现在二十五六岁，大学毕业两三年，或者差不多研究生刚毕业。你有着一份还算凑合的工作，天天宅在冷气十足的办公室里，每个月拿到手的钱，交了房租吃了饭，所剩无几。","text":"浮生若梦,若梦非梦,浮生何如,如梦之梦 ——— 庄子《如梦之梦》 你现在二十五六岁，大学毕业两三年，或者差不多研究生刚毕业。你有着一份还算凑合的工作，天天宅在冷气十足的办公室里，每个月拿到手的钱，交了房租吃了饭，所剩无几。 每天晚上六点半，当时钟跳过员工手册上写着的下班时间，你从来不会有任何的反应。 离开校园上班不过两三年，你已经写成了一套属于自己的作息节奏： 你每天晚上七点下楼，去楼下的小餐馆来一碗重庆小面吸嗦满嘴是油；七点半你上楼继续坐在办公桌前干活；你心里想着，妈蛋怎么都没有人下班，真是一群神经病；殊不知你也可能一不留神成为另一个人心中的神经病；九点半，你终于收拾东西，回到你的出租房。 你躺在床上，辗转反侧，寂寞难眠，你总觉的你一天什么事情都没干，青春不是应该释放激情与梦想吗？怎么看起来那么颓废。你盘算着明天就辞职，然后去自驾游，去看海，去隐居，但想到银行卡的余额，你呵呵呵呵呵笑起来，还是算了吧！ 那些曾经的同学们都开始结婚了。你在微信里收到了一条条设计华丽带着动画和音乐的婚礼邀请函。你一边用没时间婉拒着他们的婚礼邀请，一边感叹，卧槽这么早就结婚了。 你想找个人谈恋爱，可是你还没准备好，在你的生命中出现另外一个人是多么的累。你根本就忘记了如何去爱。 你说你满怀理想，你文艺青年，你从来觉得在农家菜馆聚餐点一桌子毛血旺是一件很low的事情，你从来都厌恶一群人的娱乐生活只有去洗脚、按摩、打麻将、去KTV唱爱情买卖。 你觉得你想要的生活绝不是这样。 你穷，你却喜欢健身，喜欢吉他、喜欢巴洛克音乐与延时摄影，你坚持去健身，你坚持去听独立歌手的演出，你坚持读书。你就是这么的逼格甚高，但你每天都过得好不快乐。 你一直还是认为爱情是件很美好的事情，你一定要找到那个对的人，你没有主动去追逐某些人，你相信缘分。然而现在，你已经失去了好多的机会，你身边的异性们，一个个脱离单身，而你，却只能假装用”不讲究“的理由默默承受着焦虑。 当然，更悲剧的是，每天的枯燥的工作，和虚无缥缈的理想追求，占据了你大量的思考的时间，你已经习惯了你现在的状态。单身，对你来说是一个安全的保护区，你根本不敢去突破你的保护区，你觉得你根本没经济接受你的生命中多出来的那个人。 你一无所有，在大城市里你没有房子和车子，你没有时间，没有喜欢的人，没有理想；你离家千里，你忘了自己当时为什么路途遥遥来到这里，住在这租来的小房子里，却每天只是为了在这里睡上一觉。 其实你一直觉得自己还很年轻。你才毕业两三年，你在任何的职业发展中都只是一个初级的小白。可是你却发现，一切都变得和以前完全不一样了，见到好久不见老朋友，你不会再和他互骂傻逼，不会再和他深夜饮酒不醉不归，不会再和他骑行百公里，只为去想去的地方看一看大海。如今的你，和他一壶清茶，聊起的话题，都是关于工作、婚姻和财富自由。你终于变成了你以前所讨厌的那个能在众人面前谈笑风生好几个小时，讲着一个丑的不行的PPT自嗨的不行的那个人。 你从未想过，这一切，居然变得那么快。 你身边的朋友，买车了、买房了、辞职了、环游世界了、家里拆迁了、创业了融资了、结婚了。每一天，你的内心都在经受着来自他人的波澜。你无奈，你沮丧，你迷失了自己。在你的出租房的公用卫生间里，刷牙洗脸，你看着墙壁上镜子中的自己：又丑又穷；一口漱口水吐掉之后，你终于自言自语对自己说：“难怪没有人喜欢我”。 那么，然后呢？ 就这样随波逐流，还是做出改变，还是坚持自我呢？ 人生如戏，或者是孤独地像条狗，或者是假装合群扮小丑，都是你自己的选择。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云，摘抄","slug":"不知所云，摘抄","permalink":"http://litxiaosa.me/tags/不知所云，摘抄/"}]},{"title":"风景旧曾谙","slug":"风景旧曾谙","date":"2017-06-30T02:41:15.000Z","updated":"2017-12-04T02:19:40.022Z","comments":true,"path":"2017/06/30/风景旧曾谙/","link":"","permalink":"http://litxiaosa.me/2017/06/30/风景旧曾谙/","excerpt":"七月将至， 天气慢慢炎热而躁动。来杭州已九月有余。 初来杭州，怀着美好的憧憬一心想去走走，看许仙和白娘子相遇的断桥，看充满神话色彩的雷峰塔。看济公修行之地灵隐寺等等。 然而始终未曾迈出一步。一来公司996累成狗，二来无人同行，感觉会少很多乐趣。","text":"七月将至， 天气慢慢炎热而躁动。来杭州已九月有余。 初来杭州，怀着美好的憧憬一心想去走走，看许仙和白娘子相遇的断桥，看充满神话色彩的雷峰塔。看济公修行之地灵隐寺等等。 然而始终未曾迈出一步。一来公司996累成狗，二来无人同行，感觉会少很多乐趣。 上班、吃饭、下班、睡觉的机械日子就这样慢慢过去了。 人嘛，总会厌烦浑浑噩噩的生活，我开始买了很多书，东野圭吾的，三毛的，韩寒的，余华的等等。开始充实自己，除了代码外，我开始享受这些，不说提高什么，觉得比下班打游戏看电视有意义些。 说起健身，还是合租的一个姑娘带我去的。她说要去减肥，我说，走，我也去，我要去增肥。她鄙视我说等我真的增肥成功了，想减肥就难了。然而，一个月过去了，我体重一毛没增加。但是胳膊和胸部的肌肉稍微有一丢丢凸显了。这也是成果。不能急，我相信胸肌会有的，腹肌也会有的。 换了公司，自由时间也多了。慢慢培养起来的爱好和习惯，更有时间和理由去坚持了，决定出去走走，把刚来杭州的憧憬，一点点实现。 不为别的，我只是不想满足于现状。 和朋友扯淡的时间慢慢少了，有时偶尔聊起天来，他们会说，最近跟灭绝了似的。“哈哈。是的，我在努力提高自己，寻找我的意中人 ”我笑。 可能是代码写多了，感觉世界的逻辑有时很简单。 事情无非是let，变化历历 或者是const，永恒安息 如果一开始就想清楚，留不住的就随风去，不会变的就钉到骨子里。那你说多轻松。 打雷了，杭州的天总是这样，大太阳说下雨就下雨，也凉快了不少。 偌大的杭州，一个人独来独往。不过每一天过的也很充实。江南好， 风景旧曾谙。我喜欢。","categories":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/categories/不知所云/"}],"tags":[{"name":"不知所云","slug":"不知所云","permalink":"http://litxiaosa.me/tags/不知所云/"}]},{"title":"MAC下配置环境变量","slug":"MAC下配置环境变量","date":"2017-06-25T02:29:23.000Z","updated":"2017-12-04T04:33:30.252Z","comments":true,"path":"2017/06/25/MAC下配置环境变量/","link":"","permalink":"http://litxiaosa.me/2017/06/25/MAC下配置环境变量/","excerpt":"配置JAVA环境变量大家在windows里面配置JDK环境变量很容易，但是如果要在mac里面配置JDK环境变量和windows里面有所不同,虽然Mac自带有jdk,但是版本比较低。我们讲的是自己下载的jdk。 jdk的下载路径， Library:就是资源库 1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home","text":"配置JAVA环境变量大家在windows里面配置JDK环境变量很容易，但是如果要在mac里面配置JDK环境变量和windows里面有所不同,虽然Mac自带有jdk,但是版本比较低。我们讲的是自己下载的jdk。 jdk的下载路径， Library:就是资源库 1/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home 打开配置文件 .bash_profile 1open .bash_profile 如果没有 .bash_profile 创建文件后打开 1touch .bash_profile 把下面的代码复制进去, 注意替换成你的jdk版本 12345export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Homeexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport $JAVA_HOME/bin:$PATH: 然后保存并退出 .bash_profile 输入下面的命令使修改生效 1source .bash_profile 使用如下命令查看环境变量是否已经配置成功： 1echo $JAVA_HOME 如果出现下图，说明配置成功了 配置maven环境变量打开终端,输入 1open .bash_profile 输入Maven安装包路径, 注意替换成你的解压路径 123export M2_HOME=/Library/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 保存修改并关闭 .bash_profile 输入 source .bash_profile 使修改生效 输入 mvn -v 验证Maven是否配置成功，如果显示Maven版本信息则配置成功。","categories":[{"name":"环境变量","slug":"环境变量","permalink":"http://litxiaosa.me/categories/环境变量/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://litxiaosa.me/tags/环境变量/"}]},{"title":"hexo绑定域名","slug":"hexo绑定域名","date":"2017-06-24T12:20:38.000Z","updated":"2017-12-04T02:19:59.741Z","comments":true,"path":"2017/06/24/hexo绑定域名/","link":"","permalink":"http://litxiaosa.me/2017/06/24/hexo绑定域名/","excerpt":"因为Hexo个人博客是托管在github之上，每次访问都要使用githubyourname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。","text":"因为Hexo个人博客是托管在github之上，每次访问都要使用githubyourname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。 购买域名国内国外有很多的域名供应商，选择一个好的机构购买域名，我是在阿里的万网购买的。通过搜索找到自己喜欢的域名，然后加入清单，然后去付款就好了。 现在你的域名还处于sever状态，你需要去实名认证，上传你的身份证正面照就好了，官方说3～5个工作日，不过我的一天就认证好了。 然后你需要进行域名解析。进入阿里云控制台 点击域名，进入下图页面 点击解析 记录类型选择:CNAME主机记录选择：*记录值： 你的github博客网址 ,我的是litxiaosa.github.io hexo 添加CNAME文件这些全部设置完成后，此时你并不能要申请的域名访问你的博客，接着你需要做的是在blog根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：litxiaosa.me 然后等几分钟访问一下吧。 安装畅言评论系统现在你已经有了域名和备案了，那么我们就可以安装畅言评论系统了，这里是畅言官方网站。注册账号，去认证，备案，这里默认这一系列步骤都操作完成了。 然后我们登陆账号，进入后台，下面有个畅言秘钥。 由于该主题没有集成畅言评论，所以我们得自己配置,在_yelee/layout/_partial/comments 文件夹中新建一个 changyan.ejs 的文件，把上边那个代码拷贝进去，然后appid替换成你的appid， conf替换成你的appKey。添加 红色框住的代码。保存。 进入 layout/_partial/article.ejs 文件， 添加一下代码 12&lt;% &#125; else if (theme.changyan.on) &#123; %&gt; &lt;%- partial('comments/changyan') %&gt; 进入 _config.yml 根目录 添加下面的配置。 部署线上，就看到添加的评论系统了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"安装和配置主题","slug":"安装和配置主题","date":"2017-06-24T07:27:36.000Z","updated":"2017-12-04T04:45:38.257Z","comments":true,"path":"2017/06/24/安装和配置主题/","link":"","permalink":"http://litxiaosa.me/2017/06/24/安装和配置主题/","excerpt":"安装主题hexo 自带的主题略显简单了，这里我们介绍安装yelee主题，你也可以选择其他主题，只是把路径改成你想安装主题的路径就好了，进入你之前创建的文件夹下，执行下面的命令 1git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 等它克隆好了以后，你就会看到你的文件夹下/themes多了一个yelee文件夹","text":"安装主题hexo 自带的主题略显简单了，这里我们介绍安装yelee主题，你也可以选择其他主题，只是把路径改成你想安装主题的路径就好了，进入你之前创建的文件夹下，执行下面的命令 1git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 等它克隆好了以后，你就会看到你的文件夹下/themes多了一个yelee文件夹 切换主题修改根目blog根目录下的 _config.yml 修改主题设置接下来，让我们看看主题的配置文件吧。进入yelee目录，打开该目录的 _config.yml ,这里是我配置的。都有中文注释，应该可以看懂的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301# Theme Version | 当前版本Yelee: \"3.5\"# &gt;&gt;\" Basic Setup | 基础设置 &lt;&lt;&lt;# Header | 主菜单## About Page: `hexo new page about`## Tags Cloud Page: `hexo new page tags`menu: 主页: / 所有文章: /archives/ #随笔: /tags/随笔 标签云: /tags/ 关于我: /about/# Link to your avatar | 填写头像地址avatar: /img/头像.jpg# Small icon of Your site | 站点小图标地址favicon: /站点小图标.jpg# Internationalization | 主题语言## Change Language in SITE's _config.yml | 在站点配置中切换语言## https://hexo.io/docs/internationalization.html## Available Languages: en, zh-Hans, zh-Hant-TW, zh-Hant-HK# Subdirectory | 子目录## If your site' url is 'http://yoursite.com/blog', set root_url as '/blog/'## 网站若存放在子目录，请按上面格式填写## https://hexo.io/docs/configuration.html#URLroot_url:# Year of Site Creation | 网站成立年份since: 2017# Social info. Bar | 社交信息展示## Keep \"mailto:\" in Email | 设置 Email 时保留 \"mailto:\"## Encrypt email 加密邮件地址 http://ctrlq.org/encode/## RSS requires a plugin to take effect | 使用 RSS 需先安装对应插件## https://github.com/hexojs/hexo-generator-feedsubnav: #Email: \"mailto:123@123.com\" 新浪微博: \"\" GitHub: \"\" #V2EX: \"#\" #RSS: \"/atom.xml\" 知乎: \"\" #豆瓣: \"douban\" #简书: \"jianshu\" #SegmentFault: \"\" #博客园: \"cnblogs\" #CSDN: \"\" #Coding: \"\" #网易云音乐: \"netease\" #虾米音乐: \"xiami\" #bilibili: \"\" #AcFun: \"\" #niconico: \"\" #Quora: \"\" #Facebook: \"#\" #Google: \"#\" #Twitter: \"#\" #LinkedIn: \"#\" #QQ: \"#\" #微信: \"Wechat\" #PayPal: \"#\" #StackOverflow: \"#\" #CodePen: \"\" #Plunker: \"\" #Instagram: \"#\" #LOFTER: \"\" #Flickr: \"#\" #reddit: \"\" #Medium: \"\" #TiddlyWiki: \"\" #Tumblr: \"\" #_500px: \"\"# &gt;&gt;&gt; Conments 评论系统 &lt;&lt;&lt;# Chose ONE as your comment system and keep others disable.# 选一个作为网站评论系统，其他保持禁用。preload_comment: true## false: 当点击评论条等区域时再加载评论模块## false: load comment's section until u click/hover on the bar/iconshow_count: false## 是否在主页文章标题旁显示评论数（多说、Disqus）## Add comment count after article titledisqus: #on: true shortname: # https://help.disqus.com/customer/en/portal/articles/466208-what-s-a-shortname- # It is unnecessary to enable disqus here if # you have set \"disqus_shortname\" in your site's \"_config.yml\"duoshuo: #on: true domain: # 是否开启多说评论，http://duoshuo.com/create-site/ # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分 # http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)youyan: #on: true id: # 是否开启友言评论，http://www.uyan.cc/index.php # id 中填写你的友言用户数字ID，注册后进入后台管理即可查看 # 友言服务在 Web 环境下运行，普通本地环境无法查看，请部署后在线上测试。# &gt;&gt;&gt; Style Customisation 样式自定义 &lt;&lt;&lt;# Background | 背景## \"5\": show images form bg-1.jpg to bg-5.jpg in `/yelee/source/background/`## \"5\": 显示`/yelee/source/background/`文件夹中 bg-1.jpg 到 bg-5.jpg 这5张图片## \"0\": white-gray background | 淳朴灰白背景background_image: 5# Base Font Size | 字号调节base_font_size: 16 #px, 16 - 24## General Color Scheme | 主题配色方案## 可用值 Value: yiliacolor_scheme:highlight_style: on: true inline_code: 2 # Value: 0 - 9 可选 code_block: 0 # Value: 0 - 4 # Set inline_code to style highlight text # Chose a highlight theme for code block # 通过 inline_code 切换内置文本高亮样式 # 通过 code_block 切换内置代码高亮配色主题blockquote_style: on: true blockquote: 3 # Value: 0 - 7 可选 # 自定义文章「引用部分」的样式# Headings Style | 标题风格## 0-Yelee, 1-Yilia, 2-GitHubheading_style: 0 # Value: 0 - 2## List style type (ul) | 无序列表项标记样式list_style: 0 # value: 0 - 12 可选# 左边栏宽度 pxleft_col_width: 300# Copyright info. of post | 文末版权信息copyright: false# Table of contents | 文章目录toc: on: true list_number: true # 目录序号 max_depth: 5 # 1 - 6 (h1-h6) 目录最大级数 nowrap: false # Keep title on same line | 目录标题不换行# 是否开启主页及加载头像时的动画效果# Animation in Homepage and Loading avataranimate: true# Load jQuery UI to style tooltips# 工具提示框样式美化jquery_ui: true# Max width of right cloumn | 限制右侧内容的宽带limit_article_width: on: false max_width: 60 # em# &gt;&gt;&gt; Small features | 小功能设置 &lt;&lt;&lt;# 是否开启边栏多标签切换# Birdhouse button in left columntagcloud: true# Blogroll, Link exchange | 友情链接#friends: #Hexo: https://hexo.io #GitHub: https://pages.github.com/ #MOxFIVE: http://moxfive.xyz/friends: true#是否开启“关于我”。aboutme: #aboutme: true# Open link in a new tab | 是否在新窗口打开链接## `global` 0: Set separately, 1: Open all in new 2: Open all in current## `global` 0: 分开设置, 1: 全部在新标签打开, 2: 全部在\"当前\"标签打开open_in_new: global: 0 # 0-2 title: false # article title in homepage 主页文章标题 post: true # link within post/page 正文中的链接 tags: false # 标签 categories: false # 分类 article_nav: false # 导航 archives: false # 归档 mini_archives: false # 迷你归档 menu: false # 边栏菜单 friends: true # 友情链接 socail: false # 社交图标# Customize feed link 自定义订阅地址rss: /atom.xml# Update Reminder for IE6/7/8# 针对 IE6/7/8 的升级浏览器提示ie_updater: on: true link: //outdatedbrowser.com/ ## http://browsehappy.com/ ## http://outdatedbrowser.com/# Tab Title Change | 标签页标题切换tab_title_change: on: true left_tab_title: '(つェ⊂) 我藏好了哦~ ' return_tab_title: '(*´∇｀*) 被你发现啦~ '# &gt;&gt;&gt; Vendors | 第三方工具 &amp; 服务 &lt;&lt;&lt;# Local Site Search | 本地站内搜索## Insatall below plugin to take effect | 使用搜索需先安装对应插件## https://github.com/PaicHyperionDev/hexo-generator-searchsearch: on: true onload: false ## true: get search.xml file when the page has loaded ## false: get the file when search box gets focus# images viewer | 图片浏览器## http://www.fancyapps.com/fancybox/fancybox: true# Display Math(LaTeX, MathML...) | 数学公式支持## https://www.mathjax.org/mathjax: true# Socail Share | 是否开启分享share: on: true baidu: true addthis: false addthis_pubid: ## Go to www.addthis.com/dashboard to get your pubid (in src of Code) ## and customize AddThis share buttons# 百度、谷歌站长验证。填写 HTML 标签 content# Site Verification for Google and Baidu. HTML label content.baidu_site:google_site:# Fill in Google Analytics tracking ID, #e.g. UA-XXXXX-Xgoogle_analytics:# 百度统计 http://sitecenter.baidu.com/sc-web/# 查看代码，填入 //hm.baidu.com/hm.js? 之后的内容baidu_tongji: #填入 //hm.baidu.com/hm.js? 之后的内容# 不蒜子网站计数设置# http://ibruce.info/2015/04/04/busuanzi/visit_counter: on: true site_visit: true page_visit: true# GitHub Repo Widget# https://github.com/hustcc/GitHub-Repo-Widget.jsgithub_widget: false# Progress Bar | 页面加载进度条# Demo: http://github.hubspot.com/pace/docs/welcome/# type: barber-shop|big-counter|bounce|center-atom|center-circle|# center-radar|center-simple|corner-indicator|flash|flat-top|# loading-bar|mac-osx|minimal# color: black|blue|green|orange|pink|purple|red|silver|white|yellow|progressBar: on: true type: \"minimal\" # Keep Quotes | 保留引号避免出错 color: blueCDN: jquery: //cdn.bootcss.com/jquery/2.2.4/jquery.min.js require: //cdn.bootcss.com/require.js/2.2.0/require.min.js fontawesome: //cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css fancybox_js: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css animate_css: //cdn.bootcss.com/animate.css/3.5.1/animate.min.css jquery_ui_js: //cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js jquery_ui_css: //cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css pace_js: //cdn.bootcss.com/pace/1.0.2/pace.min.js clipboard: //cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js mathjax: //cdn.bootcss.com/mathjax/2.6.1/MathJax.js scrollreveal: //cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js blog根目录下的 _config.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 潇洒的博客subtitle: 隔岸无旧情，姑苏有钟声。description: 喜欢看书，对吉他有点小兴趣，专注JAVA。author: 潇洒language:timezone: #网站时区。Hexo 默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://litxiaosa.meroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writingnew_post_name: :title.md # File name of new posts # 新建文章默认文件名default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tab # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: true #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: true #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章highlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:Litxiaosa/Litxiaosa.github.io.git branch: master 个人头像默认头像存储于 yelee/source/img/avatar.png，你可以替换你想要的图片，也可以上网上的图片链接. HTTPS事项如果你的站点通过 HTTPS 访问，那下列的服务可能 无法正常使用： 多说评论友言评论百度分享百度统计 可使用下列支持 HTTPS 的服务替代 Disqus 评论AddThis谷歌分析 文章摘要如果你写的文章过长，全部展示是很难看的，所以在文章里你想折叠的地方可以写 &lt;!-- more --&gt; 标签云页面如果你想开启标签云，在 blog/source 文件夹下新建一个 tags 文件夹 ，里面新建一个 index.md 的文件，然后把下面的内容拷进去 1234layout: tagstitle: tags --- 本地站内搜索使用搜索需先安装对应插件，用于生成索引数据,执行下面的命令 1npm install hexo-generator-search --save 然后，在你的主题 _config.ymd 文件里, 改为 on: true即为启用搜索 123search: on: true onload: false onload: true : 索引数据 search.xml 随页面一起加载 [效率优先] onload: false : 当激活搜索框时再下载索引数据 [按需加载] 站点小图标若将图标存储 yelee/source/favicon.png,则配置中对应填写 /favicon.png，另外填网络图片的地址也可 1favicon: /favicon.png 结果如下： 网页背景图背景图文件所在路径: /yelee/source/background/ themes/yelee/_config.yml 背景参数:background_image: 5默认值为5，可按需修改“5”: 设置/yelee/source/background/文件夹中 bg-1.jpg 到 bg-5.jpg 这5张图片为背景“0”: 取消网页背景图，使用淳朴的灰白主题","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"hexo+github搭建自己的个人博客","slug":"hexo-github搭建自己的个人博客","date":"2017-06-24T02:01:03.000Z","updated":"2017-12-04T04:42:07.061Z","comments":true,"path":"2017/06/24/hexo-github搭建自己的个人博客/","link":"","permalink":"http://litxiaosa.me/2017/06/24/hexo-github搭建自己的个人博客/","excerpt":"由于个人电脑是Mac, 所以这里就以Mac OS为参考，其实Mac跟windows搭建博客差别不大，如果用windows的朋友觉得不适，请移步之嘟嘟MD的独立博客，有详细的windows平台下的教程。嗯，那我们开始吧。","text":"由于个人电脑是Mac, 所以这里就以Mac OS为参考，其实Mac跟windows搭建博客差别不大，如果用windows的朋友觉得不适，请移步之嘟嘟MD的独立博客，有详细的windows平台下的教程。嗯，那我们开始吧。 安装Git点击进入git官网，下载安装包，然后按步骤安装就好。可以输入下面的命令查看git是否安装成功。 1git --version 安装 Node.js点击进入 node.js官网，一个是通用版，一个是最新版，选择一个下载，然后按步骤安装。 安装hexo 下载安装hexo 1npm install -g hexo 安装好以后，在终端输入： 1hexo 如果出现下图，则说明安装成功： 初始化博客 建立一个博客的文件夹,blog是文件夹名字，可以根据自己的喜好定义 1hexo init blog 然后进入该文件夹 1cd blog 运行node.js 命令，根据博客默认的配置安装必要的依赖包 1npm install 初始化完成后，我们可以看到博客的文件夹 那么基本的搭建过程就完成了，让我们看看效果吧，这里介绍几个命令。 12345hexo clean #清理缓存，如果你改动了东西，没有效果，试试这个命吧。hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章 在你的终端 hexo目录下执行下面的命令 12hexo g hexo s 然后浏览器访问http://localhost:4000, 此时，你应该看到你的博客了。当然了，这个博客只是本地的，别人是看不到了，你需要把它放到github上。 注册github账号如果您已有github账号，请跳过，进入github进行注册，邮箱和密码请记好。 创建repository repository就相当于一个仓库，存放你代码的地方，点击 new repository 填写你的项目名字repository name, 这个名字格式要为youname.github.io, 例如我的xiaosa.github.io, 填写完以后点击下面的 creat创建。 部署本地项目到github上 编辑它，在_config.yml最下方，添加如下配置(记得改成自己的。另外记得一点，hexo的配置文件中任何’:’后面都是带一个空格的) github是你之前创建仓库的地址，可以通过下图获得 然后保存它，如果你是第一次使用github或者使用过但是没有配置过SSH,可能你需要配置一下，可以检查一下是否已经存在SSH Keys 1~/.ssh/ .ssh文件为隐藏文件，需要先设置隐藏文件可见才可以看到。 如果不存在，输入下面的命令创建。 1ssh-keygen -t rsa -C \"你注册github的邮箱\" 一路回车就好，这个不需要设置密码，因为这个Key仅仅用于简单的服务，完成后输入命令打开 id_rsa.pub 1cat ~/.ssh/id_rsa.pub 然后你就会得到最后面含有你邮箱的公钥，复制它。去你的github下。 title随便写，把复制的公钥粘贴到key里。点下面的add SSH key。好了。基本配置就完了。下面我们把我们的代码传到 github上，在终端输入 12hexo ghexo d 如果执行hexo d 报下面的错误 就先安装一下hexo-deployer-git,再执行 hexo d 1npm install hexo-deployer-git --save 至此，我们的项目就部署到github上了。 那么，访问博客的链接是什么呢？ 点击标注的Settings,往下拉，如果你看到的是这样的。那么点击那个 None，选择第一个，点save. 访问你博客的链接就出来了，去访问试试吧！ 发表文章既然博客搭建好了，就发表一下文章看看效果吧。hexo中写文章使用的是Markdown，语法不难，看一下就会了。然后去下载一个Markdown的编辑器，很多，看个人喜好。 在终端的blog路径下输入 1hexo new \"my new post\" 然后就会在你 blog/source/_posts 下生成一个 .md 的文件，以后你的文章就存放到这里，你也可以直接在这里新建一个 .md 的文件。写完文章后，你可以使用 hexo g 命令生成静态文件， 然后hexo s 进行本地预览。感觉没问题了，hexo d 上传到github上吧。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://litxiaosa.me/tags/hexo/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2017-06-24T01:01:03.000Z","updated":"2017-12-04T02:17:50.410Z","comments":true,"path":"2017/06/24/HelloWorld/","link":"","permalink":"http://litxiaosa.me/2017/06/24/HelloWorld/","excerpt":"","text":"在嘟嘟MD技术博客的帮助下，属于我自己的博客终于搭建起来了！ 折腾了好几天，在github page上看到自己的博客加载下来时，油然而生的成就感，兴奋了半上午。期间也踩了不少的坑，再一次感谢嘟嘟MD的指导。是的，它不是QQ空间，不是微博，也不是贴吧，它是属于自己的一个块小小的领地，所以我满足于这种归属感。 学编程时输入的第一个词语就是hello world！它更是一种象征。那第一篇文章就献给你吧。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://litxiaosa.me/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://litxiaosa.me/tags/随笔/"}]}]}